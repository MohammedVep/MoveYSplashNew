(globalThis.TURBOPACK || (globalThis.TURBOPACK = [])).push([typeof document === "object" ? document.currentScript : undefined,
"[project]/node_modules/clsx/dist/clsx.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "clsx",
    ()=>clsx,
    "default",
    ()=>__TURBOPACK__default__export__
]);
function r(e) {
    var t, f, n = "";
    if ("string" == typeof e || "number" == typeof e) n += e;
    else if ("object" == typeof e) if (Array.isArray(e)) {
        var o = e.length;
        for(t = 0; t < o; t++)e[t] && (f = r(e[t])) && (n && (n += " "), n += f);
    } else for(f in e)e[f] && (n && (n += " "), n += f);
    return n;
}
function clsx() {
    for(var e, t, f = 0, n = "", o = arguments.length; f < o; f++)(e = arguments[f]) && (t = r(e)) && (n && (n += " "), n += t);
    return n;
}
const __TURBOPACK__default__export__ = clsx;
}),
"[project]/node_modules/class-variance-authority/dist/index.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Copyright 2022 Joe Bell. All rights reserved.
 *
 * This file is licensed to you under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR REPRESENTATIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */ __turbopack_context__.s([
    "cva",
    ()=>cva,
    "cx",
    ()=>cx
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$clsx$2f$dist$2f$clsx$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/clsx/dist/clsx.mjs [app-client] (ecmascript)");
;
const falsyToString = (value)=>typeof value === "boolean" ? `${value}` : value === 0 ? "0" : value;
const cx = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$clsx$2f$dist$2f$clsx$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clsx"];
const cva = (base, config)=>(props)=>{
        var _config_compoundVariants;
        if ((config === null || config === void 0 ? void 0 : config.variants) == null) return cx(base, props === null || props === void 0 ? void 0 : props.class, props === null || props === void 0 ? void 0 : props.className);
        const { variants, defaultVariants } = config;
        const getVariantClassNames = Object.keys(variants).map((variant)=>{
            const variantProp = props === null || props === void 0 ? void 0 : props[variant];
            const defaultVariantProp = defaultVariants === null || defaultVariants === void 0 ? void 0 : defaultVariants[variant];
            if (variantProp === null) return null;
            const variantKey = falsyToString(variantProp) || falsyToString(defaultVariantProp);
            return variants[variant][variantKey];
        });
        const propsWithoutUndefined = props && Object.entries(props).reduce((acc, param)=>{
            let [key, value] = param;
            if (value === undefined) {
                return acc;
            }
            acc[key] = value;
            return acc;
        }, {});
        const getCompoundVariantClassNames = config === null || config === void 0 ? void 0 : (_config_compoundVariants = config.compoundVariants) === null || _config_compoundVariants === void 0 ? void 0 : _config_compoundVariants.reduce((acc, param)=>{
            let { class: cvClass, className: cvClassName, ...compoundVariantOptions } = param;
            return Object.entries(compoundVariantOptions).every((param)=>{
                let [key, value] = param;
                return Array.isArray(value) ? value.includes({
                    ...defaultVariants,
                    ...propsWithoutUndefined
                }[key]) : ({
                    ...defaultVariants,
                    ...propsWithoutUndefined
                })[key] === value;
            }) ? [
                ...acc,
                cvClass,
                cvClassName
            ] : acc;
        }, []);
        return cx(base, getVariantClassNames, getCompoundVariantClassNames, props === null || props === void 0 ? void 0 : props.class, props === null || props === void 0 ? void 0 : props.className);
    };
}),
"[project]/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * @license React
 * use-sync-external-store-shim.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
"production" !== ("TURBOPACK compile-time value", "development") && function() {
    function is(x, y) {
        return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
    }
    function useSyncExternalStore$2(subscribe, getSnapshot) {
        didWarnOld18Alpha || void 0 === React.startTransition || (didWarnOld18Alpha = !0, console.error("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."));
        var value = getSnapshot();
        if (!didWarnUncachedGetSnapshot) {
            var cachedValue = getSnapshot();
            objectIs(value, cachedValue) || (console.error("The result of getSnapshot should be cached to avoid an infinite loop"), didWarnUncachedGetSnapshot = !0);
        }
        cachedValue = useState({
            inst: {
                value: value,
                getSnapshot: getSnapshot
            }
        });
        var inst = cachedValue[0].inst, forceUpdate = cachedValue[1];
        useLayoutEffect({
            "useSyncExternalStore$2.useLayoutEffect": function() {
                inst.value = value;
                inst.getSnapshot = getSnapshot;
                checkIfSnapshotChanged(inst) && forceUpdate({
                    inst: inst
                });
            }
        }["useSyncExternalStore$2.useLayoutEffect"], [
            subscribe,
            value,
            getSnapshot
        ]);
        useEffect({
            "useSyncExternalStore$2.useEffect": function() {
                checkIfSnapshotChanged(inst) && forceUpdate({
                    inst: inst
                });
                return subscribe({
                    "useSyncExternalStore$2.useEffect": function() {
                        checkIfSnapshotChanged(inst) && forceUpdate({
                            inst: inst
                        });
                    }
                }["useSyncExternalStore$2.useEffect"]);
            }
        }["useSyncExternalStore$2.useEffect"], [
            subscribe
        ]);
        useDebugValue(value);
        return value;
    }
    function checkIfSnapshotChanged(inst) {
        var latestGetSnapshot = inst.getSnapshot;
        inst = inst.value;
        try {
            var nextValue = latestGetSnapshot();
            return !objectIs(inst, nextValue);
        } catch (error) {
            return !0;
        }
    }
    function useSyncExternalStore$1(subscribe, getSnapshot) {
        return getSnapshot();
    }
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var React = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)"), objectIs = "function" === typeof Object.is ? Object.is : is, useState = React.useState, useEffect = React.useEffect, useLayoutEffect = React.useLayoutEffect, useDebugValue = React.useDebugValue, didWarnOld18Alpha = !1, didWarnUncachedGetSnapshot = !1, shim = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? useSyncExternalStore$1 : useSyncExternalStore$2;
    exports.useSyncExternalStore = void 0 !== React.useSyncExternalStore ? React.useSyncExternalStore : shim;
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
}();
}),
"[project]/node_modules/use-sync-external-store/shim/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
'use strict';
if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
;
else {
    module.exports = __turbopack_context__.r("[project]/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js [app-client] (ecmascript)");
}
}),
"[project]/node_modules/sonner/dist/index.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Toaster",
    ()=>Toaster,
    "toast",
    ()=>toast,
    "useSonner",
    ()=>useSonner
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$dom$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react-dom/index.js [app-client] (ecmascript)");
'use client';
function __insertCSS(code) {
    if (!code || typeof document == 'undefined') return;
    let head = document.head || document.getElementsByTagName('head')[0];
    let style = document.createElement('style');
    style.type = 'text/css';
    head.appendChild(style);
    style.styleSheet ? style.styleSheet.cssText = code : style.appendChild(document.createTextNode(code));
}
;
;
const getAsset = (type)=>{
    switch(type){
        case 'success':
            return SuccessIcon;
        case 'info':
            return InfoIcon;
        case 'warning':
            return WarningIcon;
        case 'error':
            return ErrorIcon;
        default:
            return null;
    }
};
const bars = Array(12).fill(0);
const Loader = ({ visible, className })=>{
    return /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement("div", {
        className: [
            'sonner-loading-wrapper',
            className
        ].filter(Boolean).join(' '),
        "data-visible": visible
    }, /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement("div", {
        className: "sonner-spinner"
    }, bars.map((_, i)=>/*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement("div", {
            className: "sonner-loading-bar",
            key: `spinner-bar-${i}`
        }))));
};
const SuccessIcon = /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor",
    height: "20",
    width: "20"
}, /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement("path", {
    fillRule: "evenodd",
    d: "M10 18a8 8 0 100-16 8 8 0 000 16zm3.857-9.809a.75.75 0 00-1.214-.882l-3.483 4.79-1.88-1.88a.75.75 0 10-1.06 1.061l2.5 2.5a.75.75 0 001.137-.089l4-5.5z",
    clipRule: "evenodd"
}));
const WarningIcon = /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    height: "20",
    width: "20"
}, /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement("path", {
    fillRule: "evenodd",
    d: "M9.401 3.003c1.155-2 4.043-2 5.197 0l7.355 12.748c1.154 2-.29 4.5-2.599 4.5H4.645c-2.309 0-3.752-2.5-2.598-4.5L9.4 3.003zM12 8.25a.75.75 0 01.75.75v3.75a.75.75 0 01-1.5 0V9a.75.75 0 01.75-.75zm0 8.25a.75.75 0 100-1.5.75.75 0 000 1.5z",
    clipRule: "evenodd"
}));
const InfoIcon = /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor",
    height: "20",
    width: "20"
}, /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement("path", {
    fillRule: "evenodd",
    d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a.75.75 0 000 1.5h.253a.25.25 0 01.244.304l-.459 2.066A1.75 1.75 0 0010.747 15H11a.75.75 0 000-1.5h-.253a.25.25 0 01-.244-.304l.459-2.066A1.75 1.75 0 009.253 9H9z",
    clipRule: "evenodd"
}));
const ErrorIcon = /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor",
    height: "20",
    width: "20"
}, /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement("path", {
    fillRule: "evenodd",
    d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-5a.75.75 0 01.75.75v4.5a.75.75 0 01-1.5 0v-4.5A.75.75 0 0110 5zm0 10a1 1 0 100-2 1 1 0 000 2z",
    clipRule: "evenodd"
}));
const CloseIcon = /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "12",
    height: "12",
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "1.5",
    strokeLinecap: "round",
    strokeLinejoin: "round"
}, /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement("line", {
    x1: "18",
    y1: "6",
    x2: "6",
    y2: "18"
}), /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement("line", {
    x1: "6",
    y1: "6",
    x2: "18",
    y2: "18"
}));
const useIsDocumentHidden = ()=>{
    const [isDocumentHidden, setIsDocumentHidden] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useState(document.hidden);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useEffect({
        "useIsDocumentHidden.useEffect": ()=>{
            const callback = {
                "useIsDocumentHidden.useEffect.callback": ()=>{
                    setIsDocumentHidden(document.hidden);
                }
            }["useIsDocumentHidden.useEffect.callback"];
            document.addEventListener('visibilitychange', callback);
            return ({
                "useIsDocumentHidden.useEffect": ()=>window.removeEventListener('visibilitychange', callback)
            })["useIsDocumentHidden.useEffect"];
        }
    }["useIsDocumentHidden.useEffect"], []);
    return isDocumentHidden;
};
let toastsCounter = 1;
class Observer {
    constructor(){
        // We use arrow functions to maintain the correct `this` reference
        this.subscribe = (subscriber)=>{
            this.subscribers.push(subscriber);
            return ()=>{
                const index = this.subscribers.indexOf(subscriber);
                this.subscribers.splice(index, 1);
            };
        };
        this.publish = (data)=>{
            this.subscribers.forEach((subscriber)=>subscriber(data));
        };
        this.addToast = (data)=>{
            this.publish(data);
            this.toasts = [
                ...this.toasts,
                data
            ];
        };
        this.create = (data)=>{
            var _data_id;
            const { message, ...rest } = data;
            const id = typeof (data == null ? void 0 : data.id) === 'number' || ((_data_id = data.id) == null ? void 0 : _data_id.length) > 0 ? data.id : toastsCounter++;
            const alreadyExists = this.toasts.find((toast)=>{
                return toast.id === id;
            });
            const dismissible = data.dismissible === undefined ? true : data.dismissible;
            if (this.dismissedToasts.has(id)) {
                this.dismissedToasts.delete(id);
            }
            if (alreadyExists) {
                this.toasts = this.toasts.map((toast)=>{
                    if (toast.id === id) {
                        this.publish({
                            ...toast,
                            ...data,
                            id,
                            title: message
                        });
                        return {
                            ...toast,
                            ...data,
                            id,
                            dismissible,
                            title: message
                        };
                    }
                    return toast;
                });
            } else {
                this.addToast({
                    title: message,
                    ...rest,
                    dismissible,
                    id
                });
            }
            return id;
        };
        this.dismiss = (id)=>{
            if (id) {
                this.dismissedToasts.add(id);
                requestAnimationFrame(()=>this.subscribers.forEach((subscriber)=>subscriber({
                            id,
                            dismiss: true
                        })));
            } else {
                this.toasts.forEach((toast)=>{
                    this.subscribers.forEach((subscriber)=>subscriber({
                            id: toast.id,
                            dismiss: true
                        }));
                });
            }
            return id;
        };
        this.message = (message, data)=>{
            return this.create({
                ...data,
                message
            });
        };
        this.error = (message, data)=>{
            return this.create({
                ...data,
                message,
                type: 'error'
            });
        };
        this.success = (message, data)=>{
            return this.create({
                ...data,
                type: 'success',
                message
            });
        };
        this.info = (message, data)=>{
            return this.create({
                ...data,
                type: 'info',
                message
            });
        };
        this.warning = (message, data)=>{
            return this.create({
                ...data,
                type: 'warning',
                message
            });
        };
        this.loading = (message, data)=>{
            return this.create({
                ...data,
                type: 'loading',
                message
            });
        };
        this.promise = (promise, data)=>{
            if (!data) {
                // Nothing to show
                return;
            }
            let id = undefined;
            if (data.loading !== undefined) {
                id = this.create({
                    ...data,
                    promise,
                    type: 'loading',
                    message: data.loading,
                    description: typeof data.description !== 'function' ? data.description : undefined
                });
            }
            const p = Promise.resolve(promise instanceof Function ? promise() : promise);
            let shouldDismiss = id !== undefined;
            let result;
            const originalPromise = p.then(async (response)=>{
                result = [
                    'resolve',
                    response
                ];
                const isReactElementResponse = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isValidElement(response);
                if (isReactElementResponse) {
                    shouldDismiss = false;
                    this.create({
                        id,
                        type: 'default',
                        message: response
                    });
                } else if (isHttpResponse(response) && !response.ok) {
                    shouldDismiss = false;
                    const promiseData = typeof data.error === 'function' ? await data.error(`HTTP error! status: ${response.status}`) : data.error;
                    const description = typeof data.description === 'function' ? await data.description(`HTTP error! status: ${response.status}`) : data.description;
                    const isExtendedResult = typeof promiseData === 'object' && !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isValidElement(promiseData);
                    const toastSettings = isExtendedResult ? promiseData : {
                        message: promiseData
                    };
                    this.create({
                        id,
                        type: 'error',
                        description,
                        ...toastSettings
                    });
                } else if (response instanceof Error) {
                    shouldDismiss = false;
                    const promiseData = typeof data.error === 'function' ? await data.error(response) : data.error;
                    const description = typeof data.description === 'function' ? await data.description(response) : data.description;
                    const isExtendedResult = typeof promiseData === 'object' && !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isValidElement(promiseData);
                    const toastSettings = isExtendedResult ? promiseData : {
                        message: promiseData
                    };
                    this.create({
                        id,
                        type: 'error',
                        description,
                        ...toastSettings
                    });
                } else if (data.success !== undefined) {
                    shouldDismiss = false;
                    const promiseData = typeof data.success === 'function' ? await data.success(response) : data.success;
                    const description = typeof data.description === 'function' ? await data.description(response) : data.description;
                    const isExtendedResult = typeof promiseData === 'object' && !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isValidElement(promiseData);
                    const toastSettings = isExtendedResult ? promiseData : {
                        message: promiseData
                    };
                    this.create({
                        id,
                        type: 'success',
                        description,
                        ...toastSettings
                    });
                }
            }).catch(async (error)=>{
                result = [
                    'reject',
                    error
                ];
                if (data.error !== undefined) {
                    shouldDismiss = false;
                    const promiseData = typeof data.error === 'function' ? await data.error(error) : data.error;
                    const description = typeof data.description === 'function' ? await data.description(error) : data.description;
                    const isExtendedResult = typeof promiseData === 'object' && !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isValidElement(promiseData);
                    const toastSettings = isExtendedResult ? promiseData : {
                        message: promiseData
                    };
                    this.create({
                        id,
                        type: 'error',
                        description,
                        ...toastSettings
                    });
                }
            }).finally(()=>{
                if (shouldDismiss) {
                    // Toast is still in load state (and will be indefinitely â€” dismiss it)
                    this.dismiss(id);
                    id = undefined;
                }
                data.finally == null ? void 0 : data.finally.call(data);
            });
            const unwrap = ()=>new Promise((resolve, reject)=>originalPromise.then(()=>result[0] === 'reject' ? reject(result[1]) : resolve(result[1])).catch(reject));
            if (typeof id !== 'string' && typeof id !== 'number') {
                // cannot Object.assign on undefined
                return {
                    unwrap
                };
            } else {
                return Object.assign(id, {
                    unwrap
                });
            }
        };
        this.custom = (jsx, data)=>{
            const id = (data == null ? void 0 : data.id) || toastsCounter++;
            this.create({
                jsx: jsx(id),
                id,
                ...data
            });
            return id;
        };
        this.getActiveToasts = ()=>{
            return this.toasts.filter((toast)=>!this.dismissedToasts.has(toast.id));
        };
        this.subscribers = [];
        this.toasts = [];
        this.dismissedToasts = new Set();
    }
}
const ToastState = new Observer();
// bind this to the toast function
const toastFunction = (message, data)=>{
    const id = (data == null ? void 0 : data.id) || toastsCounter++;
    ToastState.addToast({
        title: message,
        ...data,
        id
    });
    return id;
};
const isHttpResponse = (data)=>{
    return data && typeof data === 'object' && 'ok' in data && typeof data.ok === 'boolean' && 'status' in data && typeof data.status === 'number';
};
const basicToast = toastFunction;
const getHistory = ()=>ToastState.toasts;
const getToasts = ()=>ToastState.getActiveToasts();
// We use `Object.assign` to maintain the correct types as we would lose them otherwise
const toast = Object.assign(basicToast, {
    success: ToastState.success,
    info: ToastState.info,
    warning: ToastState.warning,
    error: ToastState.error,
    custom: ToastState.custom,
    message: ToastState.message,
    promise: ToastState.promise,
    dismiss: ToastState.dismiss,
    loading: ToastState.loading
}, {
    getHistory,
    getToasts
});
__insertCSS("[data-sonner-toaster][dir=ltr],html[dir=ltr]{--toast-icon-margin-start:-3px;--toast-icon-margin-end:4px;--toast-svg-margin-start:-1px;--toast-svg-margin-end:0px;--toast-button-margin-start:auto;--toast-button-margin-end:0;--toast-close-button-start:0;--toast-close-button-end:unset;--toast-close-button-transform:translate(-35%, -35%)}[data-sonner-toaster][dir=rtl],html[dir=rtl]{--toast-icon-margin-start:4px;--toast-icon-margin-end:-3px;--toast-svg-margin-start:0px;--toast-svg-margin-end:-1px;--toast-button-margin-start:0;--toast-button-margin-end:auto;--toast-close-button-start:unset;--toast-close-button-end:0;--toast-close-button-transform:translate(35%, -35%)}[data-sonner-toaster]{position:fixed;width:var(--width);font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;--gray1:hsl(0, 0%, 99%);--gray2:hsl(0, 0%, 97.3%);--gray3:hsl(0, 0%, 95.1%);--gray4:hsl(0, 0%, 93%);--gray5:hsl(0, 0%, 90.9%);--gray6:hsl(0, 0%, 88.7%);--gray7:hsl(0, 0%, 85.8%);--gray8:hsl(0, 0%, 78%);--gray9:hsl(0, 0%, 56.1%);--gray10:hsl(0, 0%, 52.3%);--gray11:hsl(0, 0%, 43.5%);--gray12:hsl(0, 0%, 9%);--border-radius:8px;box-sizing:border-box;padding:0;margin:0;list-style:none;outline:0;z-index:999999999;transition:transform .4s ease}@media (hover:none) and (pointer:coarse){[data-sonner-toaster][data-lifted=true]{transform:none}}[data-sonner-toaster][data-x-position=right]{right:var(--offset-right)}[data-sonner-toaster][data-x-position=left]{left:var(--offset-left)}[data-sonner-toaster][data-x-position=center]{left:50%;transform:translateX(-50%)}[data-sonner-toaster][data-y-position=top]{top:var(--offset-top)}[data-sonner-toaster][data-y-position=bottom]{bottom:var(--offset-bottom)}[data-sonner-toast]{--y:translateY(100%);--lift-amount:calc(var(--lift) * var(--gap));z-index:var(--z-index);position:absolute;opacity:0;transform:var(--y);touch-action:none;transition:transform .4s,opacity .4s,height .4s,box-shadow .2s;box-sizing:border-box;outline:0;overflow-wrap:anywhere}[data-sonner-toast][data-styled=true]{padding:16px;background:var(--normal-bg);border:1px solid var(--normal-border);color:var(--normal-text);border-radius:var(--border-radius);box-shadow:0 4px 12px rgba(0,0,0,.1);width:var(--width);font-size:13px;display:flex;align-items:center;gap:6px}[data-sonner-toast]:focus-visible{box-shadow:0 4px 12px rgba(0,0,0,.1),0 0 0 2px rgba(0,0,0,.2)}[data-sonner-toast][data-y-position=top]{top:0;--y:translateY(-100%);--lift:1;--lift-amount:calc(1 * var(--gap))}[data-sonner-toast][data-y-position=bottom]{bottom:0;--y:translateY(100%);--lift:-1;--lift-amount:calc(var(--lift) * var(--gap))}[data-sonner-toast][data-styled=true] [data-description]{font-weight:400;line-height:1.4;color:#3f3f3f}[data-rich-colors=true][data-sonner-toast][data-styled=true] [data-description]{color:inherit}[data-sonner-toaster][data-sonner-theme=dark] [data-description]{color:#e8e8e8}[data-sonner-toast][data-styled=true] [data-title]{font-weight:500;line-height:1.5;color:inherit}[data-sonner-toast][data-styled=true] [data-icon]{display:flex;height:16px;width:16px;position:relative;justify-content:flex-start;align-items:center;flex-shrink:0;margin-left:var(--toast-icon-margin-start);margin-right:var(--toast-icon-margin-end)}[data-sonner-toast][data-promise=true] [data-icon]>svg{opacity:0;transform:scale(.8);transform-origin:center;animation:sonner-fade-in .3s ease forwards}[data-sonner-toast][data-styled=true] [data-icon]>*{flex-shrink:0}[data-sonner-toast][data-styled=true] [data-icon] svg{margin-left:var(--toast-svg-margin-start);margin-right:var(--toast-svg-margin-end)}[data-sonner-toast][data-styled=true] [data-content]{display:flex;flex-direction:column;gap:2px}[data-sonner-toast][data-styled=true] [data-button]{border-radius:4px;padding-left:8px;padding-right:8px;height:24px;font-size:12px;color:var(--normal-bg);background:var(--normal-text);margin-left:var(--toast-button-margin-start);margin-right:var(--toast-button-margin-end);border:none;font-weight:500;cursor:pointer;outline:0;display:flex;align-items:center;flex-shrink:0;transition:opacity .4s,box-shadow .2s}[data-sonner-toast][data-styled=true] [data-button]:focus-visible{box-shadow:0 0 0 2px rgba(0,0,0,.4)}[data-sonner-toast][data-styled=true] [data-button]:first-of-type{margin-left:var(--toast-button-margin-start);margin-right:var(--toast-button-margin-end)}[data-sonner-toast][data-styled=true] [data-cancel]{color:var(--normal-text);background:rgba(0,0,0,.08)}[data-sonner-toaster][data-sonner-theme=dark] [data-sonner-toast][data-styled=true] [data-cancel]{background:rgba(255,255,255,.3)}[data-sonner-toast][data-styled=true] [data-close-button]{position:absolute;left:var(--toast-close-button-start);right:var(--toast-close-button-end);top:0;height:20px;width:20px;display:flex;justify-content:center;align-items:center;padding:0;color:var(--gray12);background:var(--normal-bg);border:1px solid var(--gray4);transform:var(--toast-close-button-transform);border-radius:50%;cursor:pointer;z-index:1;transition:opacity .1s,background .2s,border-color .2s}[data-sonner-toast][data-styled=true] [data-close-button]:focus-visible{box-shadow:0 4px 12px rgba(0,0,0,.1),0 0 0 2px rgba(0,0,0,.2)}[data-sonner-toast][data-styled=true] [data-disabled=true]{cursor:not-allowed}[data-sonner-toast][data-styled=true]:hover [data-close-button]:hover{background:var(--gray2);border-color:var(--gray5)}[data-sonner-toast][data-swiping=true]::before{content:'';position:absolute;left:-100%;right:-100%;height:100%;z-index:-1}[data-sonner-toast][data-y-position=top][data-swiping=true]::before{bottom:50%;transform:scaleY(3) translateY(50%)}[data-sonner-toast][data-y-position=bottom][data-swiping=true]::before{top:50%;transform:scaleY(3) translateY(-50%)}[data-sonner-toast][data-swiping=false][data-removed=true]::before{content:'';position:absolute;inset:0;transform:scaleY(2)}[data-sonner-toast][data-expanded=true]::after{content:'';position:absolute;left:0;height:calc(var(--gap) + 1px);bottom:100%;width:100%}[data-sonner-toast][data-mounted=true]{--y:translateY(0);opacity:1}[data-sonner-toast][data-expanded=false][data-front=false]{--scale:var(--toasts-before) * 0.05 + 1;--y:translateY(calc(var(--lift-amount) * var(--toasts-before))) scale(calc(-1 * var(--scale)));height:var(--front-toast-height)}[data-sonner-toast]>*{transition:opacity .4s}[data-sonner-toast][data-x-position=right]{right:0}[data-sonner-toast][data-x-position=left]{left:0}[data-sonner-toast][data-expanded=false][data-front=false][data-styled=true]>*{opacity:0}[data-sonner-toast][data-visible=false]{opacity:0;pointer-events:none}[data-sonner-toast][data-mounted=true][data-expanded=true]{--y:translateY(calc(var(--lift) * var(--offset)));height:var(--initial-height)}[data-sonner-toast][data-removed=true][data-front=true][data-swipe-out=false]{--y:translateY(calc(var(--lift) * -100%));opacity:0}[data-sonner-toast][data-removed=true][data-front=false][data-swipe-out=false][data-expanded=true]{--y:translateY(calc(var(--lift) * var(--offset) + var(--lift) * -100%));opacity:0}[data-sonner-toast][data-removed=true][data-front=false][data-swipe-out=false][data-expanded=false]{--y:translateY(40%);opacity:0;transition:transform .5s,opacity .2s}[data-sonner-toast][data-removed=true][data-front=false]::before{height:calc(var(--initial-height) + 20%)}[data-sonner-toast][data-swiping=true]{transform:var(--y) translateY(var(--swipe-amount-y,0)) translateX(var(--swipe-amount-x,0));transition:none}[data-sonner-toast][data-swiped=true]{user-select:none}[data-sonner-toast][data-swipe-out=true][data-y-position=bottom],[data-sonner-toast][data-swipe-out=true][data-y-position=top]{animation-duration:.2s;animation-timing-function:ease-out;animation-fill-mode:forwards}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=left]{animation-name:swipe-out-left}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=right]{animation-name:swipe-out-right}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=up]{animation-name:swipe-out-up}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=down]{animation-name:swipe-out-down}@keyframes swipe-out-left{from{transform:var(--y) translateX(var(--swipe-amount-x));opacity:1}to{transform:var(--y) translateX(calc(var(--swipe-amount-x) - 100%));opacity:0}}@keyframes swipe-out-right{from{transform:var(--y) translateX(var(--swipe-amount-x));opacity:1}to{transform:var(--y) translateX(calc(var(--swipe-amount-x) + 100%));opacity:0}}@keyframes swipe-out-up{from{transform:var(--y) translateY(var(--swipe-amount-y));opacity:1}to{transform:var(--y) translateY(calc(var(--swipe-amount-y) - 100%));opacity:0}}@keyframes swipe-out-down{from{transform:var(--y) translateY(var(--swipe-amount-y));opacity:1}to{transform:var(--y) translateY(calc(var(--swipe-amount-y) + 100%));opacity:0}}@media (max-width:600px){[data-sonner-toaster]{position:fixed;right:var(--mobile-offset-right);left:var(--mobile-offset-left);width:100%}[data-sonner-toaster][dir=rtl]{left:calc(var(--mobile-offset-left) * -1)}[data-sonner-toaster] [data-sonner-toast]{left:0;right:0;width:calc(100% - var(--mobile-offset-left) * 2)}[data-sonner-toaster][data-x-position=left]{left:var(--mobile-offset-left)}[data-sonner-toaster][data-y-position=bottom]{bottom:var(--mobile-offset-bottom)}[data-sonner-toaster][data-y-position=top]{top:var(--mobile-offset-top)}[data-sonner-toaster][data-x-position=center]{left:var(--mobile-offset-left);right:var(--mobile-offset-right);transform:none}}[data-sonner-toaster][data-sonner-theme=light]{--normal-bg:#fff;--normal-border:var(--gray4);--normal-text:var(--gray12);--success-bg:hsl(143, 85%, 96%);--success-border:hsl(145, 92%, 87%);--success-text:hsl(140, 100%, 27%);--info-bg:hsl(208, 100%, 97%);--info-border:hsl(221, 91%, 93%);--info-text:hsl(210, 92%, 45%);--warning-bg:hsl(49, 100%, 97%);--warning-border:hsl(49, 91%, 84%);--warning-text:hsl(31, 92%, 45%);--error-bg:hsl(359, 100%, 97%);--error-border:hsl(359, 100%, 94%);--error-text:hsl(360, 100%, 45%)}[data-sonner-toaster][data-sonner-theme=light] [data-sonner-toast][data-invert=true]{--normal-bg:#000;--normal-border:hsl(0, 0%, 20%);--normal-text:var(--gray1)}[data-sonner-toaster][data-sonner-theme=dark] [data-sonner-toast][data-invert=true]{--normal-bg:#fff;--normal-border:var(--gray3);--normal-text:var(--gray12)}[data-sonner-toaster][data-sonner-theme=dark]{--normal-bg:#000;--normal-bg-hover:hsl(0, 0%, 12%);--normal-border:hsl(0, 0%, 20%);--normal-border-hover:hsl(0, 0%, 25%);--normal-text:var(--gray1);--success-bg:hsl(150, 100%, 6%);--success-border:hsl(147, 100%, 12%);--success-text:hsl(150, 86%, 65%);--info-bg:hsl(215, 100%, 6%);--info-border:hsl(223, 43%, 17%);--info-text:hsl(216, 87%, 65%);--warning-bg:hsl(64, 100%, 6%);--warning-border:hsl(60, 100%, 9%);--warning-text:hsl(46, 87%, 65%);--error-bg:hsl(358, 76%, 10%);--error-border:hsl(357, 89%, 16%);--error-text:hsl(358, 100%, 81%)}[data-sonner-toaster][data-sonner-theme=dark] [data-sonner-toast] [data-close-button]{background:var(--normal-bg);border-color:var(--normal-border);color:var(--normal-text)}[data-sonner-toaster][data-sonner-theme=dark] [data-sonner-toast] [data-close-button]:hover{background:var(--normal-bg-hover);border-color:var(--normal-border-hover)}[data-rich-colors=true][data-sonner-toast][data-type=success]{background:var(--success-bg);border-color:var(--success-border);color:var(--success-text)}[data-rich-colors=true][data-sonner-toast][data-type=success] [data-close-button]{background:var(--success-bg);border-color:var(--success-border);color:var(--success-text)}[data-rich-colors=true][data-sonner-toast][data-type=info]{background:var(--info-bg);border-color:var(--info-border);color:var(--info-text)}[data-rich-colors=true][data-sonner-toast][data-type=info] [data-close-button]{background:var(--info-bg);border-color:var(--info-border);color:var(--info-text)}[data-rich-colors=true][data-sonner-toast][data-type=warning]{background:var(--warning-bg);border-color:var(--warning-border);color:var(--warning-text)}[data-rich-colors=true][data-sonner-toast][data-type=warning] [data-close-button]{background:var(--warning-bg);border-color:var(--warning-border);color:var(--warning-text)}[data-rich-colors=true][data-sonner-toast][data-type=error]{background:var(--error-bg);border-color:var(--error-border);color:var(--error-text)}[data-rich-colors=true][data-sonner-toast][data-type=error] [data-close-button]{background:var(--error-bg);border-color:var(--error-border);color:var(--error-text)}.sonner-loading-wrapper{--size:16px;height:var(--size);width:var(--size);position:absolute;inset:0;z-index:10}.sonner-loading-wrapper[data-visible=false]{transform-origin:center;animation:sonner-fade-out .2s ease forwards}.sonner-spinner{position:relative;top:50%;left:50%;height:var(--size);width:var(--size)}.sonner-loading-bar{animation:sonner-spin 1.2s linear infinite;background:var(--gray11);border-radius:6px;height:8%;left:-10%;position:absolute;top:-3.9%;width:24%}.sonner-loading-bar:first-child{animation-delay:-1.2s;transform:rotate(.0001deg) translate(146%)}.sonner-loading-bar:nth-child(2){animation-delay:-1.1s;transform:rotate(30deg) translate(146%)}.sonner-loading-bar:nth-child(3){animation-delay:-1s;transform:rotate(60deg) translate(146%)}.sonner-loading-bar:nth-child(4){animation-delay:-.9s;transform:rotate(90deg) translate(146%)}.sonner-loading-bar:nth-child(5){animation-delay:-.8s;transform:rotate(120deg) translate(146%)}.sonner-loading-bar:nth-child(6){animation-delay:-.7s;transform:rotate(150deg) translate(146%)}.sonner-loading-bar:nth-child(7){animation-delay:-.6s;transform:rotate(180deg) translate(146%)}.sonner-loading-bar:nth-child(8){animation-delay:-.5s;transform:rotate(210deg) translate(146%)}.sonner-loading-bar:nth-child(9){animation-delay:-.4s;transform:rotate(240deg) translate(146%)}.sonner-loading-bar:nth-child(10){animation-delay:-.3s;transform:rotate(270deg) translate(146%)}.sonner-loading-bar:nth-child(11){animation-delay:-.2s;transform:rotate(300deg) translate(146%)}.sonner-loading-bar:nth-child(12){animation-delay:-.1s;transform:rotate(330deg) translate(146%)}@keyframes sonner-fade-in{0%{opacity:0;transform:scale(.8)}100%{opacity:1;transform:scale(1)}}@keyframes sonner-fade-out{0%{opacity:1;transform:scale(1)}100%{opacity:0;transform:scale(.8)}}@keyframes sonner-spin{0%{opacity:1}100%{opacity:.15}}@media (prefers-reduced-motion){.sonner-loading-bar,[data-sonner-toast],[data-sonner-toast]>*{transition:none!important;animation:none!important}}.sonner-loader{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);transform-origin:center;transition:opacity .2s,transform .2s}.sonner-loader[data-visible=false]{opacity:0;transform:scale(.8) translate(-50%,-50%)}");
function isAction(action) {
    return action.label !== undefined;
}
// Visible toasts amount
const VISIBLE_TOASTS_AMOUNT = 3;
// Viewport padding
const VIEWPORT_OFFSET = '24px';
// Mobile viewport padding
const MOBILE_VIEWPORT_OFFSET = '16px';
// Default lifetime of a toasts (in ms)
const TOAST_LIFETIME = 4000;
// Default toast width
const TOAST_WIDTH = 356;
// Default gap between toasts
const GAP = 14;
// Threshold to dismiss a toast
const SWIPE_THRESHOLD = 45;
// Equal to exit animation duration
const TIME_BEFORE_UNMOUNT = 200;
function cn(...classes) {
    return classes.filter(Boolean).join(' ');
}
function getDefaultSwipeDirections(position) {
    const [y, x] = position.split('-');
    const directions = [];
    if (y) {
        directions.push(y);
    }
    if (x) {
        directions.push(x);
    }
    return directions;
}
const Toast = (props)=>{
    var _toast_classNames, _toast_classNames1, _toast_classNames2, _toast_classNames3, _toast_classNames4, _toast_classNames5, _toast_classNames6, _toast_classNames7, _toast_classNames8;
    const { invert: ToasterInvert, toast, unstyled, interacting, setHeights, visibleToasts, heights, index, toasts, expanded, removeToast, defaultRichColors, closeButton: closeButtonFromToaster, style, cancelButtonStyle, actionButtonStyle, className = '', descriptionClassName = '', duration: durationFromToaster, position, gap, expandByDefault, classNames, icons, closeButtonAriaLabel = 'Close toast' } = props;
    const [swipeDirection, setSwipeDirection] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useState(null);
    const [swipeOutDirection, setSwipeOutDirection] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useState(null);
    const [mounted, setMounted] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useState(false);
    const [removed, setRemoved] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useState(false);
    const [swiping, setSwiping] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useState(false);
    const [swipeOut, setSwipeOut] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useState(false);
    const [isSwiped, setIsSwiped] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useState(false);
    const [offsetBeforeRemove, setOffsetBeforeRemove] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useState(0);
    const [initialHeight, setInitialHeight] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useState(0);
    const remainingTime = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useRef(toast.duration || durationFromToaster || TOAST_LIFETIME);
    const dragStartTime = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useRef(null);
    const toastRef = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useRef(null);
    const isFront = index === 0;
    const isVisible = index + 1 <= visibleToasts;
    const toastType = toast.type;
    const dismissible = toast.dismissible !== false;
    const toastClassname = toast.className || '';
    const toastDescriptionClassname = toast.descriptionClassName || '';
    // Height index is used to calculate the offset as it gets updated before the toast array, which means we can calculate the new layout faster.
    const heightIndex = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useMemo({
        "Toast.useMemo[heightIndex]": ()=>heights.findIndex({
                "Toast.useMemo[heightIndex]": (height)=>height.toastId === toast.id
            }["Toast.useMemo[heightIndex]"]) || 0
    }["Toast.useMemo[heightIndex]"], [
        heights,
        toast.id
    ]);
    const closeButton = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useMemo({
        "Toast.useMemo[closeButton]": ()=>{
            var _toast_closeButton;
            return (_toast_closeButton = toast.closeButton) != null ? _toast_closeButton : closeButtonFromToaster;
        }
    }["Toast.useMemo[closeButton]"], [
        toast.closeButton,
        closeButtonFromToaster
    ]);
    const duration = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useMemo({
        "Toast.useMemo[duration]": ()=>toast.duration || durationFromToaster || TOAST_LIFETIME
    }["Toast.useMemo[duration]"], [
        toast.duration,
        durationFromToaster
    ]);
    const closeTimerStartTimeRef = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useRef(0);
    const offset = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useRef(0);
    const lastCloseTimerStartTimeRef = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useRef(0);
    const pointerStartRef = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useRef(null);
    const [y, x] = position.split('-');
    const toastsHeightBefore = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useMemo({
        "Toast.useMemo[toastsHeightBefore]": ()=>{
            return heights.reduce({
                "Toast.useMemo[toastsHeightBefore]": (prev, curr, reducerIndex)=>{
                    // Calculate offset up until current toast
                    if (reducerIndex >= heightIndex) {
                        return prev;
                    }
                    return prev + curr.height;
                }
            }["Toast.useMemo[toastsHeightBefore]"], 0);
        }
    }["Toast.useMemo[toastsHeightBefore]"], [
        heights,
        heightIndex
    ]);
    const isDocumentHidden = useIsDocumentHidden();
    const invert = toast.invert || ToasterInvert;
    const disabled = toastType === 'loading';
    offset.current = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useMemo({
        "Toast.useMemo": ()=>heightIndex * gap + toastsHeightBefore
    }["Toast.useMemo"], [
        heightIndex,
        toastsHeightBefore
    ]);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useEffect({
        "Toast.useEffect": ()=>{
            remainingTime.current = duration;
        }
    }["Toast.useEffect"], [
        duration
    ]);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useEffect({
        "Toast.useEffect": ()=>{
            // Trigger enter animation without using CSS animation
            setMounted(true);
        }
    }["Toast.useEffect"], []);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useEffect({
        "Toast.useEffect": ()=>{
            const toastNode = toastRef.current;
            if (toastNode) {
                const height = toastNode.getBoundingClientRect().height;
                // Add toast height to heights array after the toast is mounted
                setInitialHeight(height);
                setHeights({
                    "Toast.useEffect": (h)=>[
                            {
                                toastId: toast.id,
                                height,
                                position: toast.position
                            },
                            ...h
                        ]
                }["Toast.useEffect"]);
                return ({
                    "Toast.useEffect": ()=>setHeights({
                            "Toast.useEffect": (h)=>h.filter({
                                    "Toast.useEffect": (height)=>height.toastId !== toast.id
                                }["Toast.useEffect"])
                        }["Toast.useEffect"])
                })["Toast.useEffect"];
            }
        }
    }["Toast.useEffect"], [
        setHeights,
        toast.id
    ]);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useLayoutEffect({
        "Toast.useLayoutEffect": ()=>{
            // Keep height up to date with the content in case it updates
            if (!mounted) return;
            const toastNode = toastRef.current;
            const originalHeight = toastNode.style.height;
            toastNode.style.height = 'auto';
            const newHeight = toastNode.getBoundingClientRect().height;
            toastNode.style.height = originalHeight;
            setInitialHeight(newHeight);
            setHeights({
                "Toast.useLayoutEffect": (heights)=>{
                    const alreadyExists = heights.find({
                        "Toast.useLayoutEffect.alreadyExists": (height)=>height.toastId === toast.id
                    }["Toast.useLayoutEffect.alreadyExists"]);
                    if (!alreadyExists) {
                        return [
                            {
                                toastId: toast.id,
                                height: newHeight,
                                position: toast.position
                            },
                            ...heights
                        ];
                    } else {
                        return heights.map({
                            "Toast.useLayoutEffect": (height)=>height.toastId === toast.id ? {
                                    ...height,
                                    height: newHeight
                                } : height
                        }["Toast.useLayoutEffect"]);
                    }
                }
            }["Toast.useLayoutEffect"]);
        }
    }["Toast.useLayoutEffect"], [
        mounted,
        toast.title,
        toast.description,
        setHeights,
        toast.id,
        toast.jsx,
        toast.action,
        toast.cancel
    ]);
    const deleteToast = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useCallback({
        "Toast.useCallback[deleteToast]": ()=>{
            // Save the offset for the exit swipe animation
            setRemoved(true);
            setOffsetBeforeRemove(offset.current);
            setHeights({
                "Toast.useCallback[deleteToast]": (h)=>h.filter({
                        "Toast.useCallback[deleteToast]": (height)=>height.toastId !== toast.id
                    }["Toast.useCallback[deleteToast]"])
            }["Toast.useCallback[deleteToast]"]);
            setTimeout({
                "Toast.useCallback[deleteToast]": ()=>{
                    removeToast(toast);
                }
            }["Toast.useCallback[deleteToast]"], TIME_BEFORE_UNMOUNT);
        }
    }["Toast.useCallback[deleteToast]"], [
        toast,
        removeToast,
        setHeights,
        offset
    ]);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useEffect({
        "Toast.useEffect": ()=>{
            if (toast.promise && toastType === 'loading' || toast.duration === Infinity || toast.type === 'loading') return;
            let timeoutId;
            // Pause the timer on each hover
            const pauseTimer = {
                "Toast.useEffect.pauseTimer": ()=>{
                    if (lastCloseTimerStartTimeRef.current < closeTimerStartTimeRef.current) {
                        // Get the elapsed time since the timer started
                        const elapsedTime = new Date().getTime() - closeTimerStartTimeRef.current;
                        remainingTime.current = remainingTime.current - elapsedTime;
                    }
                    lastCloseTimerStartTimeRef.current = new Date().getTime();
                }
            }["Toast.useEffect.pauseTimer"];
            const startTimer = {
                "Toast.useEffect.startTimer": ()=>{
                    // setTimeout(, Infinity) behaves as if the delay is 0.
                    // As a result, the toast would be closed immediately, giving the appearance that it was never rendered.
                    // See: https://github.com/denysdovhan/wtfjs?tab=readme-ov-file#an-infinite-timeout
                    if (remainingTime.current === Infinity) return;
                    closeTimerStartTimeRef.current = new Date().getTime();
                    // Let the toast know it has started
                    timeoutId = setTimeout({
                        "Toast.useEffect.startTimer": ()=>{
                            toast.onAutoClose == null ? void 0 : toast.onAutoClose.call(toast, toast);
                            deleteToast();
                        }
                    }["Toast.useEffect.startTimer"], remainingTime.current);
                }
            }["Toast.useEffect.startTimer"];
            if (expanded || interacting || isDocumentHidden) {
                pauseTimer();
            } else {
                startTimer();
            }
            return ({
                "Toast.useEffect": ()=>clearTimeout(timeoutId)
            })["Toast.useEffect"];
        }
    }["Toast.useEffect"], [
        expanded,
        interacting,
        toast,
        toastType,
        isDocumentHidden,
        deleteToast
    ]);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useEffect({
        "Toast.useEffect": ()=>{
            if (toast.delete) {
                deleteToast();
                toast.onDismiss == null ? void 0 : toast.onDismiss.call(toast, toast);
            }
        }
    }["Toast.useEffect"], [
        deleteToast,
        toast.delete
    ]);
    function getLoadingIcon() {
        var _toast_classNames;
        if (icons == null ? void 0 : icons.loading) {
            var _toast_classNames1;
            return /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement("div", {
                className: cn(classNames == null ? void 0 : classNames.loader, toast == null ? void 0 : (_toast_classNames1 = toast.classNames) == null ? void 0 : _toast_classNames1.loader, 'sonner-loader'),
                "data-visible": toastType === 'loading'
            }, icons.loading);
        }
        return /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(Loader, {
            className: cn(classNames == null ? void 0 : classNames.loader, toast == null ? void 0 : (_toast_classNames = toast.classNames) == null ? void 0 : _toast_classNames.loader),
            visible: toastType === 'loading'
        });
    }
    const icon = toast.icon || (icons == null ? void 0 : icons[toastType]) || getAsset(toastType);
    var _toast_richColors, _icons_close;
    return /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement("li", {
        tabIndex: 0,
        ref: toastRef,
        className: cn(className, toastClassname, classNames == null ? void 0 : classNames.toast, toast == null ? void 0 : (_toast_classNames = toast.classNames) == null ? void 0 : _toast_classNames.toast, classNames == null ? void 0 : classNames.default, classNames == null ? void 0 : classNames[toastType], toast == null ? void 0 : (_toast_classNames1 = toast.classNames) == null ? void 0 : _toast_classNames1[toastType]),
        "data-sonner-toast": "",
        "data-rich-colors": (_toast_richColors = toast.richColors) != null ? _toast_richColors : defaultRichColors,
        "data-styled": !Boolean(toast.jsx || toast.unstyled || unstyled),
        "data-mounted": mounted,
        "data-promise": Boolean(toast.promise),
        "data-swiped": isSwiped,
        "data-removed": removed,
        "data-visible": isVisible,
        "data-y-position": y,
        "data-x-position": x,
        "data-index": index,
        "data-front": isFront,
        "data-swiping": swiping,
        "data-dismissible": dismissible,
        "data-type": toastType,
        "data-invert": invert,
        "data-swipe-out": swipeOut,
        "data-swipe-direction": swipeOutDirection,
        "data-expanded": Boolean(expanded || expandByDefault && mounted),
        "data-testid": toast.testId,
        style: {
            '--index': index,
            '--toasts-before': index,
            '--z-index': toasts.length - index,
            '--offset': `${removed ? offsetBeforeRemove : offset.current}px`,
            '--initial-height': expandByDefault ? 'auto' : `${initialHeight}px`,
            ...style,
            ...toast.style
        },
        onDragEnd: ()=>{
            setSwiping(false);
            setSwipeDirection(null);
            pointerStartRef.current = null;
        },
        onPointerDown: (event)=>{
            if (event.button === 2) return; // Return early on right click
            if (disabled || !dismissible) return;
            dragStartTime.current = new Date();
            setOffsetBeforeRemove(offset.current);
            // Ensure we maintain correct pointer capture even when going outside of the toast (e.g. when swiping)
            event.target.setPointerCapture(event.pointerId);
            if (event.target.tagName === 'BUTTON') return;
            setSwiping(true);
            pointerStartRef.current = {
                x: event.clientX,
                y: event.clientY
            };
        },
        onPointerUp: ()=>{
            var _toastRef_current, _toastRef_current1, _dragStartTime_current;
            if (swipeOut || !dismissible) return;
            pointerStartRef.current = null;
            const swipeAmountX = Number(((_toastRef_current = toastRef.current) == null ? void 0 : _toastRef_current.style.getPropertyValue('--swipe-amount-x').replace('px', '')) || 0);
            const swipeAmountY = Number(((_toastRef_current1 = toastRef.current) == null ? void 0 : _toastRef_current1.style.getPropertyValue('--swipe-amount-y').replace('px', '')) || 0);
            const timeTaken = new Date().getTime() - ((_dragStartTime_current = dragStartTime.current) == null ? void 0 : _dragStartTime_current.getTime());
            const swipeAmount = swipeDirection === 'x' ? swipeAmountX : swipeAmountY;
            const velocity = Math.abs(swipeAmount) / timeTaken;
            if (Math.abs(swipeAmount) >= SWIPE_THRESHOLD || velocity > 0.11) {
                setOffsetBeforeRemove(offset.current);
                toast.onDismiss == null ? void 0 : toast.onDismiss.call(toast, toast);
                if (swipeDirection === 'x') {
                    setSwipeOutDirection(swipeAmountX > 0 ? 'right' : 'left');
                } else {
                    setSwipeOutDirection(swipeAmountY > 0 ? 'down' : 'up');
                }
                deleteToast();
                setSwipeOut(true);
                return;
            } else {
                var _toastRef_current2, _toastRef_current3;
                (_toastRef_current2 = toastRef.current) == null ? void 0 : _toastRef_current2.style.setProperty('--swipe-amount-x', `0px`);
                (_toastRef_current3 = toastRef.current) == null ? void 0 : _toastRef_current3.style.setProperty('--swipe-amount-y', `0px`);
            }
            setIsSwiped(false);
            setSwiping(false);
            setSwipeDirection(null);
        },
        onPointerMove: (event)=>{
            var _window_getSelection, _toastRef_current, _toastRef_current1;
            if (!pointerStartRef.current || !dismissible) return;
            const isHighlighted = ((_window_getSelection = window.getSelection()) == null ? void 0 : _window_getSelection.toString().length) > 0;
            if (isHighlighted) return;
            const yDelta = event.clientY - pointerStartRef.current.y;
            const xDelta = event.clientX - pointerStartRef.current.x;
            var _props_swipeDirections;
            const swipeDirections = (_props_swipeDirections = props.swipeDirections) != null ? _props_swipeDirections : getDefaultSwipeDirections(position);
            // Determine swipe direction if not already locked
            if (!swipeDirection && (Math.abs(xDelta) > 1 || Math.abs(yDelta) > 1)) {
                setSwipeDirection(Math.abs(xDelta) > Math.abs(yDelta) ? 'x' : 'y');
            }
            let swipeAmount = {
                x: 0,
                y: 0
            };
            const getDampening = (delta)=>{
                const factor = Math.abs(delta) / 20;
                return 1 / (1.5 + factor);
            };
            // Only apply swipe in the locked direction
            if (swipeDirection === 'y') {
                // Handle vertical swipes
                if (swipeDirections.includes('top') || swipeDirections.includes('bottom')) {
                    if (swipeDirections.includes('top') && yDelta < 0 || swipeDirections.includes('bottom') && yDelta > 0) {
                        swipeAmount.y = yDelta;
                    } else {
                        // Smoothly transition to dampened movement
                        const dampenedDelta = yDelta * getDampening(yDelta);
                        // Ensure we don't jump when transitioning to dampened movement
                        swipeAmount.y = Math.abs(dampenedDelta) < Math.abs(yDelta) ? dampenedDelta : yDelta;
                    }
                }
            } else if (swipeDirection === 'x') {
                // Handle horizontal swipes
                if (swipeDirections.includes('left') || swipeDirections.includes('right')) {
                    if (swipeDirections.includes('left') && xDelta < 0 || swipeDirections.includes('right') && xDelta > 0) {
                        swipeAmount.x = xDelta;
                    } else {
                        // Smoothly transition to dampened movement
                        const dampenedDelta = xDelta * getDampening(xDelta);
                        // Ensure we don't jump when transitioning to dampened movement
                        swipeAmount.x = Math.abs(dampenedDelta) < Math.abs(xDelta) ? dampenedDelta : xDelta;
                    }
                }
            }
            if (Math.abs(swipeAmount.x) > 0 || Math.abs(swipeAmount.y) > 0) {
                setIsSwiped(true);
            }
            (_toastRef_current = toastRef.current) == null ? void 0 : _toastRef_current.style.setProperty('--swipe-amount-x', `${swipeAmount.x}px`);
            (_toastRef_current1 = toastRef.current) == null ? void 0 : _toastRef_current1.style.setProperty('--swipe-amount-y', `${swipeAmount.y}px`);
        }
    }, closeButton && !toast.jsx && toastType !== 'loading' ? /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement("button", {
        "aria-label": closeButtonAriaLabel,
        "data-disabled": disabled,
        "data-close-button": true,
        onClick: disabled || !dismissible ? ()=>{} : ()=>{
            deleteToast();
            toast.onDismiss == null ? void 0 : toast.onDismiss.call(toast, toast);
        },
        className: cn(classNames == null ? void 0 : classNames.closeButton, toast == null ? void 0 : (_toast_classNames2 = toast.classNames) == null ? void 0 : _toast_classNames2.closeButton)
    }, (_icons_close = icons == null ? void 0 : icons.close) != null ? _icons_close : CloseIcon) : null, (toastType || toast.icon || toast.promise) && toast.icon !== null && ((icons == null ? void 0 : icons[toastType]) !== null || toast.icon) ? /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement("div", {
        "data-icon": "",
        className: cn(classNames == null ? void 0 : classNames.icon, toast == null ? void 0 : (_toast_classNames3 = toast.classNames) == null ? void 0 : _toast_classNames3.icon)
    }, toast.promise || toast.type === 'loading' && !toast.icon ? toast.icon || getLoadingIcon() : null, toast.type !== 'loading' ? icon : null) : null, /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement("div", {
        "data-content": "",
        className: cn(classNames == null ? void 0 : classNames.content, toast == null ? void 0 : (_toast_classNames4 = toast.classNames) == null ? void 0 : _toast_classNames4.content)
    }, /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement("div", {
        "data-title": "",
        className: cn(classNames == null ? void 0 : classNames.title, toast == null ? void 0 : (_toast_classNames5 = toast.classNames) == null ? void 0 : _toast_classNames5.title)
    }, toast.jsx ? toast.jsx : typeof toast.title === 'function' ? toast.title() : toast.title), toast.description ? /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement("div", {
        "data-description": "",
        className: cn(descriptionClassName, toastDescriptionClassname, classNames == null ? void 0 : classNames.description, toast == null ? void 0 : (_toast_classNames6 = toast.classNames) == null ? void 0 : _toast_classNames6.description)
    }, typeof toast.description === 'function' ? toast.description() : toast.description) : null), /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isValidElement(toast.cancel) ? toast.cancel : toast.cancel && isAction(toast.cancel) ? /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement("button", {
        "data-button": true,
        "data-cancel": true,
        style: toast.cancelButtonStyle || cancelButtonStyle,
        onClick: (event)=>{
            // We need to check twice because typescript
            if (!isAction(toast.cancel)) return;
            if (!dismissible) return;
            toast.cancel.onClick == null ? void 0 : toast.cancel.onClick.call(toast.cancel, event);
            deleteToast();
        },
        className: cn(classNames == null ? void 0 : classNames.cancelButton, toast == null ? void 0 : (_toast_classNames7 = toast.classNames) == null ? void 0 : _toast_classNames7.cancelButton)
    }, toast.cancel.label) : null, /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isValidElement(toast.action) ? toast.action : toast.action && isAction(toast.action) ? /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement("button", {
        "data-button": true,
        "data-action": true,
        style: toast.actionButtonStyle || actionButtonStyle,
        onClick: (event)=>{
            // We need to check twice because typescript
            if (!isAction(toast.action)) return;
            toast.action.onClick == null ? void 0 : toast.action.onClick.call(toast.action, event);
            if (event.defaultPrevented) return;
            deleteToast();
        },
        className: cn(classNames == null ? void 0 : classNames.actionButton, toast == null ? void 0 : (_toast_classNames8 = toast.classNames) == null ? void 0 : _toast_classNames8.actionButton)
    }, toast.action.label) : null);
};
function getDocumentDirection() {
    if (typeof window === 'undefined') return 'ltr';
    if (typeof document === 'undefined') return 'ltr'; // For Fresh purpose
    const dirAttribute = document.documentElement.getAttribute('dir');
    if (dirAttribute === 'auto' || !dirAttribute) {
        return window.getComputedStyle(document.documentElement).direction;
    }
    return dirAttribute;
}
function assignOffset(defaultOffset, mobileOffset) {
    const styles = {};
    [
        defaultOffset,
        mobileOffset
    ].forEach((offset, index)=>{
        const isMobile = index === 1;
        const prefix = isMobile ? '--mobile-offset' : '--offset';
        const defaultValue = isMobile ? MOBILE_VIEWPORT_OFFSET : VIEWPORT_OFFSET;
        function assignAll(offset) {
            [
                'top',
                'right',
                'bottom',
                'left'
            ].forEach((key)=>{
                styles[`${prefix}-${key}`] = typeof offset === 'number' ? `${offset}px` : offset;
            });
        }
        if (typeof offset === 'number' || typeof offset === 'string') {
            assignAll(offset);
        } else if (typeof offset === 'object') {
            [
                'top',
                'right',
                'bottom',
                'left'
            ].forEach((key)=>{
                if (offset[key] === undefined) {
                    styles[`${prefix}-${key}`] = defaultValue;
                } else {
                    styles[`${prefix}-${key}`] = typeof offset[key] === 'number' ? `${offset[key]}px` : offset[key];
                }
            });
        } else {
            assignAll(defaultValue);
        }
    });
    return styles;
}
function useSonner() {
    const [activeToasts, setActiveToasts] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useState([]);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useEffect({
        "useSonner.useEffect": ()=>{
            return ToastState.subscribe({
                "useSonner.useEffect": (toast)=>{
                    if (toast.dismiss) {
                        setTimeout({
                            "useSonner.useEffect": ()=>{
                                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$dom$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].flushSync({
                                    "useSonner.useEffect": ()=>{
                                        setActiveToasts({
                                            "useSonner.useEffect": (toasts)=>toasts.filter({
                                                    "useSonner.useEffect": (t)=>t.id !== toast.id
                                                }["useSonner.useEffect"])
                                        }["useSonner.useEffect"]);
                                    }
                                }["useSonner.useEffect"]);
                            }
                        }["useSonner.useEffect"]);
                        return;
                    }
                    // Prevent batching, temp solution.
                    setTimeout({
                        "useSonner.useEffect": ()=>{
                            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$dom$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].flushSync({
                                "useSonner.useEffect": ()=>{
                                    setActiveToasts({
                                        "useSonner.useEffect": (toasts)=>{
                                            const indexOfExistingToast = toasts.findIndex({
                                                "useSonner.useEffect.indexOfExistingToast": (t)=>t.id === toast.id
                                            }["useSonner.useEffect.indexOfExistingToast"]);
                                            // Update the toast if it already exists
                                            if (indexOfExistingToast !== -1) {
                                                return [
                                                    ...toasts.slice(0, indexOfExistingToast),
                                                    {
                                                        ...toasts[indexOfExistingToast],
                                                        ...toast
                                                    },
                                                    ...toasts.slice(indexOfExistingToast + 1)
                                                ];
                                            }
                                            return [
                                                toast,
                                                ...toasts
                                            ];
                                        }
                                    }["useSonner.useEffect"]);
                                }
                            }["useSonner.useEffect"]);
                        }
                    }["useSonner.useEffect"]);
                }
            }["useSonner.useEffect"]);
        }
    }["useSonner.useEffect"], []);
    return {
        toasts: activeToasts
    };
}
const Toaster = /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].forwardRef(function Toaster(props, ref) {
    const { id, invert, position = 'bottom-right', hotkey = [
        'altKey',
        'KeyT'
    ], expand, closeButton, className, offset, mobileOffset, theme = 'light', richColors, duration, style, visibleToasts = VISIBLE_TOASTS_AMOUNT, toastOptions, dir = getDocumentDirection(), gap = GAP, icons, containerAriaLabel = 'Notifications' } = props;
    const [toasts, setToasts] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useState([]);
    const filteredToasts = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useMemo({
        "Toaster.Toaster.useMemo[filteredToasts]": ()=>{
            if (id) {
                return toasts.filter({
                    "Toaster.Toaster.useMemo[filteredToasts]": (toast)=>toast.toasterId === id
                }["Toaster.Toaster.useMemo[filteredToasts]"]);
            }
            return toasts.filter({
                "Toaster.Toaster.useMemo[filteredToasts]": (toast)=>!toast.toasterId
            }["Toaster.Toaster.useMemo[filteredToasts]"]);
        }
    }["Toaster.Toaster.useMemo[filteredToasts]"], [
        toasts,
        id
    ]);
    const possiblePositions = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useMemo({
        "Toaster.Toaster.useMemo[possiblePositions]": ()=>{
            return Array.from(new Set([
                position
            ].concat(filteredToasts.filter({
                "Toaster.Toaster.useMemo[possiblePositions]": (toast)=>toast.position
            }["Toaster.Toaster.useMemo[possiblePositions]"]).map({
                "Toaster.Toaster.useMemo[possiblePositions]": (toast)=>toast.position
            }["Toaster.Toaster.useMemo[possiblePositions]"]))));
        }
    }["Toaster.Toaster.useMemo[possiblePositions]"], [
        filteredToasts,
        position
    ]);
    const [heights, setHeights] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useState([]);
    const [expanded, setExpanded] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useState(false);
    const [interacting, setInteracting] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useState(false);
    const [actualTheme, setActualTheme] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useState(theme !== 'system' ? theme : typeof window !== 'undefined' ? window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light' : 'light');
    const listRef = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useRef(null);
    const hotkeyLabel = hotkey.join('+').replace(/Key/g, '').replace(/Digit/g, '');
    const lastFocusedElementRef = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useRef(null);
    const isFocusWithinRef = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useRef(false);
    const removeToast = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useCallback({
        "Toaster.Toaster.useCallback[removeToast]": (toastToRemove)=>{
            setToasts({
                "Toaster.Toaster.useCallback[removeToast]": (toasts)=>{
                    var _toasts_find;
                    if (!((_toasts_find = toasts.find({
                        "Toaster.Toaster.useCallback[removeToast]": (toast)=>toast.id === toastToRemove.id
                    }["Toaster.Toaster.useCallback[removeToast]"])) == null ? void 0 : _toasts_find.delete)) {
                        ToastState.dismiss(toastToRemove.id);
                    }
                    return toasts.filter({
                        "Toaster.Toaster.useCallback[removeToast]": ({ id })=>id !== toastToRemove.id
                    }["Toaster.Toaster.useCallback[removeToast]"]);
                }
            }["Toaster.Toaster.useCallback[removeToast]"]);
        }
    }["Toaster.Toaster.useCallback[removeToast]"], []);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useEffect({
        "Toaster.Toaster.useEffect": ()=>{
            return ToastState.subscribe({
                "Toaster.Toaster.useEffect": (toast)=>{
                    if (toast.dismiss) {
                        // Prevent batching of other state updates
                        requestAnimationFrame({
                            "Toaster.Toaster.useEffect": ()=>{
                                setToasts({
                                    "Toaster.Toaster.useEffect": (toasts)=>toasts.map({
                                            "Toaster.Toaster.useEffect": (t)=>t.id === toast.id ? {
                                                    ...t,
                                                    delete: true
                                                } : t
                                        }["Toaster.Toaster.useEffect"])
                                }["Toaster.Toaster.useEffect"]);
                            }
                        }["Toaster.Toaster.useEffect"]);
                        return;
                    }
                    // Prevent batching, temp solution.
                    setTimeout({
                        "Toaster.Toaster.useEffect": ()=>{
                            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$dom$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].flushSync({
                                "Toaster.Toaster.useEffect": ()=>{
                                    setToasts({
                                        "Toaster.Toaster.useEffect": (toasts)=>{
                                            const indexOfExistingToast = toasts.findIndex({
                                                "Toaster.Toaster.useEffect.indexOfExistingToast": (t)=>t.id === toast.id
                                            }["Toaster.Toaster.useEffect.indexOfExistingToast"]);
                                            // Update the toast if it already exists
                                            if (indexOfExistingToast !== -1) {
                                                return [
                                                    ...toasts.slice(0, indexOfExistingToast),
                                                    {
                                                        ...toasts[indexOfExistingToast],
                                                        ...toast
                                                    },
                                                    ...toasts.slice(indexOfExistingToast + 1)
                                                ];
                                            }
                                            return [
                                                toast,
                                                ...toasts
                                            ];
                                        }
                                    }["Toaster.Toaster.useEffect"]);
                                }
                            }["Toaster.Toaster.useEffect"]);
                        }
                    }["Toaster.Toaster.useEffect"]);
                }
            }["Toaster.Toaster.useEffect"]);
        }
    }["Toaster.Toaster.useEffect"], [
        toasts
    ]);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useEffect({
        "Toaster.Toaster.useEffect": ()=>{
            if (theme !== 'system') {
                setActualTheme(theme);
                return;
            }
            if (theme === 'system') {
                // check if current preference is dark
                if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                    // it's currently dark
                    setActualTheme('dark');
                } else {
                    // it's not dark
                    setActualTheme('light');
                }
            }
            if (typeof window === 'undefined') return;
            const darkMediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
            try {
                // Chrome & Firefox
                darkMediaQuery.addEventListener('change', {
                    "Toaster.Toaster.useEffect": ({ matches })=>{
                        if (matches) {
                            setActualTheme('dark');
                        } else {
                            setActualTheme('light');
                        }
                    }
                }["Toaster.Toaster.useEffect"]);
            } catch (error) {
                // Safari < 14
                darkMediaQuery.addListener({
                    "Toaster.Toaster.useEffect": ({ matches })=>{
                        try {
                            if (matches) {
                                setActualTheme('dark');
                            } else {
                                setActualTheme('light');
                            }
                        } catch (e) {
                            console.error(e);
                        }
                    }
                }["Toaster.Toaster.useEffect"]);
            }
        }
    }["Toaster.Toaster.useEffect"], [
        theme
    ]);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useEffect({
        "Toaster.Toaster.useEffect": ()=>{
            // Ensure expanded is always false when no toasts are present / only one left
            if (toasts.length <= 1) {
                setExpanded(false);
            }
        }
    }["Toaster.Toaster.useEffect"], [
        toasts
    ]);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useEffect({
        "Toaster.Toaster.useEffect": ()=>{
            const handleKeyDown = {
                "Toaster.Toaster.useEffect.handleKeyDown": (event)=>{
                    var _listRef_current;
                    const isHotkeyPressed = hotkey.every({
                        "Toaster.Toaster.useEffect.handleKeyDown.isHotkeyPressed": (key)=>event[key] || event.code === key
                    }["Toaster.Toaster.useEffect.handleKeyDown.isHotkeyPressed"]);
                    if (isHotkeyPressed) {
                        var _listRef_current1;
                        setExpanded(true);
                        (_listRef_current1 = listRef.current) == null ? void 0 : _listRef_current1.focus();
                    }
                    if (event.code === 'Escape' && (document.activeElement === listRef.current || ((_listRef_current = listRef.current) == null ? void 0 : _listRef_current.contains(document.activeElement)))) {
                        setExpanded(false);
                    }
                }
            }["Toaster.Toaster.useEffect.handleKeyDown"];
            document.addEventListener('keydown', handleKeyDown);
            return ({
                "Toaster.Toaster.useEffect": ()=>document.removeEventListener('keydown', handleKeyDown)
            })["Toaster.Toaster.useEffect"];
        }
    }["Toaster.Toaster.useEffect"], [
        hotkey
    ]);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useEffect({
        "Toaster.Toaster.useEffect": ()=>{
            if (listRef.current) {
                return ({
                    "Toaster.Toaster.useEffect": ()=>{
                        if (lastFocusedElementRef.current) {
                            lastFocusedElementRef.current.focus({
                                preventScroll: true
                            });
                            lastFocusedElementRef.current = null;
                            isFocusWithinRef.current = false;
                        }
                    }
                })["Toaster.Toaster.useEffect"];
            }
        }
    }["Toaster.Toaster.useEffect"], [
        listRef.current
    ]);
    return /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement("section", {
        ref: ref,
        "aria-label": `${containerAriaLabel} ${hotkeyLabel}`,
        tabIndex: -1,
        "aria-live": "polite",
        "aria-relevant": "additions text",
        "aria-atomic": "false",
        suppressHydrationWarning: true
    }, possiblePositions.map((position, index)=>{
        var _heights_;
        const [y, x] = position.split('-');
        if (!filteredToasts.length) return null;
        return /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement("ol", {
            key: position,
            dir: dir === 'auto' ? getDocumentDirection() : dir,
            tabIndex: -1,
            ref: listRef,
            className: className,
            "data-sonner-toaster": true,
            "data-sonner-theme": actualTheme,
            "data-y-position": y,
            "data-x-position": x,
            style: {
                '--front-toast-height': `${((_heights_ = heights[0]) == null ? void 0 : _heights_.height) || 0}px`,
                '--width': `${TOAST_WIDTH}px`,
                '--gap': `${gap}px`,
                ...style,
                ...assignOffset(offset, mobileOffset)
            },
            onBlur: (event)=>{
                if (isFocusWithinRef.current && !event.currentTarget.contains(event.relatedTarget)) {
                    isFocusWithinRef.current = false;
                    if (lastFocusedElementRef.current) {
                        lastFocusedElementRef.current.focus({
                            preventScroll: true
                        });
                        lastFocusedElementRef.current = null;
                    }
                }
            },
            onFocus: (event)=>{
                const isNotDismissible = event.target instanceof HTMLElement && event.target.dataset.dismissible === 'false';
                if (isNotDismissible) return;
                if (!isFocusWithinRef.current) {
                    isFocusWithinRef.current = true;
                    lastFocusedElementRef.current = event.relatedTarget;
                }
            },
            onMouseEnter: ()=>setExpanded(true),
            onMouseMove: ()=>setExpanded(true),
            onMouseLeave: ()=>{
                // Avoid setting expanded to false when interacting with a toast, e.g. swiping
                if (!interacting) {
                    setExpanded(false);
                }
            },
            onDragEnd: ()=>setExpanded(false),
            onPointerDown: (event)=>{
                const isNotDismissible = event.target instanceof HTMLElement && event.target.dataset.dismissible === 'false';
                if (isNotDismissible) return;
                setInteracting(true);
            },
            onPointerUp: ()=>setInteracting(false)
        }, filteredToasts.filter((toast)=>!toast.position && index === 0 || toast.position === position).map((toast, index)=>{
            var _toastOptions_duration, _toastOptions_closeButton;
            return /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(Toast, {
                key: toast.id,
                icons: icons,
                index: index,
                toast: toast,
                defaultRichColors: richColors,
                duration: (_toastOptions_duration = toastOptions == null ? void 0 : toastOptions.duration) != null ? _toastOptions_duration : duration,
                className: toastOptions == null ? void 0 : toastOptions.className,
                descriptionClassName: toastOptions == null ? void 0 : toastOptions.descriptionClassName,
                invert: invert,
                visibleToasts: visibleToasts,
                closeButton: (_toastOptions_closeButton = toastOptions == null ? void 0 : toastOptions.closeButton) != null ? _toastOptions_closeButton : closeButton,
                interacting: interacting,
                position: position,
                style: toastOptions == null ? void 0 : toastOptions.style,
                unstyled: toastOptions == null ? void 0 : toastOptions.unstyled,
                classNames: toastOptions == null ? void 0 : toastOptions.classNames,
                cancelButtonStyle: toastOptions == null ? void 0 : toastOptions.cancelButtonStyle,
                actionButtonStyle: toastOptions == null ? void 0 : toastOptions.actionButtonStyle,
                closeButtonAriaLabel: toastOptions == null ? void 0 : toastOptions.closeButtonAriaLabel,
                removeToast: removeToast,
                toasts: filteredToasts.filter((t)=>t.position == toast.position),
                heights: heights.filter((h)=>h.position == toast.position),
                setHeights: setHeights,
                expandByDefault: expand,
                gap: gap,
                expanded: expanded,
                swipeDirections: props.swipeDirections
            });
        }));
    }));
});
;
}),
"[project]/node_modules/tslib/tslib.es6.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */ /* global Reflect, Promise, SuppressedError, Symbol, Iterator */ __turbopack_context__.s([
    "__addDisposableResource",
    ()=>__addDisposableResource,
    "__assign",
    ()=>__assign,
    "__asyncDelegator",
    ()=>__asyncDelegator,
    "__asyncGenerator",
    ()=>__asyncGenerator,
    "__asyncValues",
    ()=>__asyncValues,
    "__await",
    ()=>__await,
    "__awaiter",
    ()=>__awaiter,
    "__classPrivateFieldGet",
    ()=>__classPrivateFieldGet,
    "__classPrivateFieldIn",
    ()=>__classPrivateFieldIn,
    "__classPrivateFieldSet",
    ()=>__classPrivateFieldSet,
    "__createBinding",
    ()=>__createBinding,
    "__decorate",
    ()=>__decorate,
    "__disposeResources",
    ()=>__disposeResources,
    "__esDecorate",
    ()=>__esDecorate,
    "__exportStar",
    ()=>__exportStar,
    "__extends",
    ()=>__extends,
    "__generator",
    ()=>__generator,
    "__importDefault",
    ()=>__importDefault,
    "__importStar",
    ()=>__importStar,
    "__makeTemplateObject",
    ()=>__makeTemplateObject,
    "__metadata",
    ()=>__metadata,
    "__param",
    ()=>__param,
    "__propKey",
    ()=>__propKey,
    "__read",
    ()=>__read,
    "__rest",
    ()=>__rest,
    "__rewriteRelativeImportExtension",
    ()=>__rewriteRelativeImportExtension,
    "__runInitializers",
    ()=>__runInitializers,
    "__setFunctionName",
    ()=>__setFunctionName,
    "__spread",
    ()=>__spread,
    "__spreadArray",
    ()=>__spreadArray,
    "__spreadArrays",
    ()=>__spreadArrays,
    "__values",
    ()=>__values,
    "default",
    ()=>__TURBOPACK__default__export__
]);
var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || ({
        __proto__: []
    }) instanceof Array && function(d, b) {
        d.__proto__ = b;
    } || function(d, b) {
        for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };
    return extendStatics(d, b);
};
function __extends(d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for(var s, i = 1, n = arguments.length; i < n; i++){
            s = arguments[i];
            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
function __rest(s, e) {
    var t = {};
    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
    }
    return t;
}
function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __param(paramIndex, decorator) {
    return function(target, key) {
        decorator(target, key, paramIndex);
    };
}
function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) {
        if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
        return f;
    }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for(var i = decorators.length - 1; i >= 0; i--){
        var context = {};
        for(var p in contextIn)context[p] = p === "access" ? {} : contextIn[p];
        for(var p in contextIn.access)context.access[p] = contextIn.access[p];
        context.addInitializer = function(f) {
            if (done) throw new TypeError("Cannot add initializers after decoration has completed");
            extraInitializers.push(accept(f || null));
        };
        var result = (0, decorators[i])(kind === "accessor" ? {
            get: descriptor.get,
            set: descriptor.set
        } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        } else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
}
;
function __runInitializers(thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for(var i = 0; i < initializers.length; i++){
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
}
;
function __propKey(x) {
    return typeof x === "symbol" ? x : "".concat(x);
}
;
function __setFunctionName(f, name, prefix) {
    if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
    return Object.defineProperty(f, "name", {
        configurable: true,
        value: prefix ? "".concat(prefix, " ", name) : name
    });
}
;
function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}
function __generator(thisArg, body) {
    var _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
    return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    //TURBOPACK unreachable
    ;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(g && (g = 0, op[0] && (_ = 0)), _)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
}
var __createBinding = Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
};
function __exportStar(m, o) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}
function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
}
function __spread() {
    for(var ar = [], i = 0; i < arguments.length; i++)ar = ar.concat(__read(arguments[i]));
    return ar;
}
function __spreadArrays() {
    for(var s = 0, i = 0, il = arguments.length; i < il; i++)s += arguments[i].length;
    for(var r = Array(s), k = 0, i = 0; i < il; i++)for(var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)r[k] = a[j];
    return r;
}
function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
}
function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
        return this;
    }, i;
    //TURBOPACK unreachable
    ;
    function awaitReturn(f) {
        return function(v) {
            return Promise.resolve(v).then(f, reject);
        };
    }
    function verb(n, f) {
        if (g[n]) {
            i[n] = function(v) {
                return new Promise(function(a, b) {
                    q.push([
                        n,
                        v,
                        a,
                        b
                    ]) > 1 || resume(n, v);
                });
            };
            if (f) i[n] = f(i[n]);
        }
    }
    function resume(n, v) {
        try {
            step(g[n](v));
        } catch (e) {
            settle(q[0][3], e);
        }
    }
    function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
    }
    function fulfill(value) {
        resume("next", value);
    }
    function reject(value) {
        resume("throw", value);
    }
    function settle(f, v) {
        if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
    }
}
function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function(e) {
        throw e;
    }), verb("return"), i[Symbol.iterator] = function() {
        return this;
    }, i;
    //TURBOPACK unreachable
    ;
    function verb(n, f) {
        i[n] = o[n] ? function(v) {
            return (p = !p) ? {
                value: __await(o[n](v)),
                done: false
            } : f ? f(v) : v;
        } : f;
    }
}
function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
    }, i);
    //TURBOPACK unreachable
    ;
    function verb(n) {
        i[n] = o[n] && function(v) {
            return new Promise(function(resolve, reject) {
                v = o[n](v), settle(resolve, reject, v.done, v.value);
            });
        };
    }
    function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v) {
            resolve({
                value: v,
                done: d
            });
        }, reject);
    }
}
function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", {
            value: raw
        });
    } else {
        cooked.raw = raw;
    }
    return cooked;
}
;
var __setModuleDefault = Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
};
var ownKeys = function(o) {
    ownKeys = Object.getOwnPropertyNames || function(o) {
        var ar = [];
        for(var k in o)if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
        return ar;
    };
    return ownKeys(o);
};
function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k = ownKeys(mod), i = 0; i < k.length; i++)if (k[i] !== "default") __createBinding(result, mod, k[i]);
    }
    __setModuleDefault(result, mod);
    return result;
}
function __importDefault(mod) {
    return mod && mod.__esModule ? mod : {
        default: mod
    };
}
function __classPrivateFieldGet(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}
function __classPrivateFieldIn(state, receiver) {
    if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function") throw new TypeError("Cannot use 'in' operator on non-object");
    return typeof state === "function" ? receiver === state : state.has(receiver);
}
function __addDisposableResource(env, value, async) {
    if (value !== null && value !== void 0) {
        if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
        var dispose, inner;
        if (async) {
            if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
            dispose = value[Symbol.asyncDispose];
        }
        if (dispose === void 0) {
            if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
            dispose = value[Symbol.dispose];
            if (async) inner = dispose;
        }
        if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
        if (inner) dispose = function() {
            try {
                inner.call(this);
            } catch (e) {
                return Promise.reject(e);
            }
        };
        env.stack.push({
            value: value,
            dispose: dispose,
            async: async
        });
    } else if (async) {
        env.stack.push({
            async: true
        });
    }
    return value;
}
var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};
function __disposeResources(env) {
    function fail(e) {
        env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
        env.hasError = true;
    }
    var r, s = 0;
    function next() {
        while(r = env.stack.pop()){
            try {
                if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
                if (r.dispose) {
                    var result = r.dispose.call(r.value);
                    if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) {
                        fail(e);
                        return next();
                    });
                } else s |= 1;
            } catch (e) {
                fail(e);
            }
        }
        if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
        if (env.hasError) throw env.error;
    }
    return next();
}
function __rewriteRelativeImportExtension(path, preserveJsx) {
    if (typeof path === "string" && /^\.\.?\//.test(path)) {
        return path.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function(m, tsx, d, ext, cm) {
            return tsx ? preserveJsx ? ".jsx" : ".js" : d && (!ext || !cm) ? m : d + ext + "." + cm.toLowerCase() + "js";
        });
    }
    return path;
}
const __TURBOPACK__default__export__ = {
    __extends,
    __assign,
    __rest,
    __decorate,
    __param,
    __esDecorate,
    __runInitializers,
    __propKey,
    __setFunctionName,
    __metadata,
    __awaiter,
    __generator,
    __createBinding,
    __exportStar,
    __values,
    __read,
    __spread,
    __spreadArrays,
    __spreadArray,
    __await,
    __asyncGenerator,
    __asyncDelegator,
    __asyncValues,
    __makeTemplateObject,
    __importStar,
    __importDefault,
    __classPrivateFieldGet,
    __classPrivateFieldSet,
    __classPrivateFieldIn,
    __addDisposableResource,
    __disposeResources,
    __rewriteRelativeImportExtension
};
}),
"[project]/node_modules/react-remove-scroll-bar/dist/es2015/constants.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "fullWidthClassName",
    ()=>fullWidthClassName,
    "noScrollbarsClassName",
    ()=>noScrollbarsClassName,
    "removedBarSizeVariable",
    ()=>removedBarSizeVariable,
    "zeroRightClassName",
    ()=>zeroRightClassName
]);
var zeroRightClassName = 'right-scroll-bar-position';
var fullWidthClassName = 'width-before-scroll-bar';
var noScrollbarsClassName = 'with-scroll-bars-hidden';
var removedBarSizeVariable = '--removed-body-scroll-bar-size';
}),
"[project]/node_modules/react-remove-scroll-bar/dist/es2015/utils.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getGapWidth",
    ()=>getGapWidth,
    "zeroGap",
    ()=>zeroGap
]);
var zeroGap = {
    left: 0,
    top: 0,
    right: 0,
    gap: 0
};
var parse = function(x) {
    return parseInt(x || '', 10) || 0;
};
var getOffset = function(gapMode) {
    var cs = window.getComputedStyle(document.body);
    var left = cs[gapMode === 'padding' ? 'paddingLeft' : 'marginLeft'];
    var top = cs[gapMode === 'padding' ? 'paddingTop' : 'marginTop'];
    var right = cs[gapMode === 'padding' ? 'paddingRight' : 'marginRight'];
    return [
        parse(left),
        parse(top),
        parse(right)
    ];
};
var getGapWidth = function(gapMode) {
    if (gapMode === void 0) {
        gapMode = 'margin';
    }
    if (typeof window === 'undefined') {
        return zeroGap;
    }
    var offsets = getOffset(gapMode);
    var documentWidth = document.documentElement.clientWidth;
    var windowWidth = window.innerWidth;
    return {
        left: offsets[0],
        top: offsets[1],
        right: offsets[2],
        gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0])
    };
};
}),
"[project]/node_modules/react-remove-scroll-bar/dist/es2015/component.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "RemoveScrollBar",
    ()=>RemoveScrollBar,
    "lockAttribute",
    ()=>lockAttribute,
    "useLockAttribute",
    ()=>useLockAttribute
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$style$2d$singleton$2f$dist$2f$es2015$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/react-style-singleton/dist/es2015/index.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$style$2d$singleton$2f$dist$2f$es2015$2f$component$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/react-style-singleton/dist/es2015/component.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$remove$2d$scroll$2d$bar$2f$dist$2f$es2015$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/react-remove-scroll-bar/dist/es2015/constants.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$remove$2d$scroll$2d$bar$2f$dist$2f$es2015$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/react-remove-scroll-bar/dist/es2015/utils.js [app-client] (ecmascript)");
;
;
;
;
var Style = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$style$2d$singleton$2f$dist$2f$es2015$2f$component$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["styleSingleton"])();
var lockAttribute = 'data-scroll-locked';
// important tip - once we measure scrollBar width and remove them
// we could not repeat this operation
// thus we are using style-singleton - only the first "yet correct" style will be applied.
var getStyles = function(_a, allowRelative, gapMode, important) {
    var left = _a.left, top = _a.top, right = _a.right, gap = _a.gap;
    if (gapMode === void 0) {
        gapMode = 'margin';
    }
    return "\n  .".concat(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$remove$2d$scroll$2d$bar$2f$dist$2f$es2015$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["noScrollbarsClassName"], " {\n   overflow: hidden ").concat(important, ";\n   padding-right: ").concat(gap, "px ").concat(important, ";\n  }\n  body[").concat(lockAttribute, "] {\n    overflow: hidden ").concat(important, ";\n    overscroll-behavior: contain;\n    ").concat([
        allowRelative && "position: relative ".concat(important, ";"),
        gapMode === 'margin' && "\n    padding-left: ".concat(left, "px;\n    padding-top: ").concat(top, "px;\n    padding-right: ").concat(right, "px;\n    margin-left:0;\n    margin-top:0;\n    margin-right: ").concat(gap, "px ").concat(important, ";\n    "),
        gapMode === 'padding' && "padding-right: ".concat(gap, "px ").concat(important, ";")
    ].filter(Boolean).join(''), "\n  }\n  \n  .").concat(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$remove$2d$scroll$2d$bar$2f$dist$2f$es2015$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["zeroRightClassName"], " {\n    right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$remove$2d$scroll$2d$bar$2f$dist$2f$es2015$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fullWidthClassName"], " {\n    margin-right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$remove$2d$scroll$2d$bar$2f$dist$2f$es2015$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["zeroRightClassName"], " .").concat(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$remove$2d$scroll$2d$bar$2f$dist$2f$es2015$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["zeroRightClassName"], " {\n    right: 0 ").concat(important, ";\n  }\n  \n  .").concat(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$remove$2d$scroll$2d$bar$2f$dist$2f$es2015$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fullWidthClassName"], " .").concat(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$remove$2d$scroll$2d$bar$2f$dist$2f$es2015$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fullWidthClassName"], " {\n    margin-right: 0 ").concat(important, ";\n  }\n  \n  body[").concat(lockAttribute, "] {\n    ").concat(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$remove$2d$scroll$2d$bar$2f$dist$2f$es2015$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["removedBarSizeVariable"], ": ").concat(gap, "px;\n  }\n");
};
var getCurrentUseCounter = function() {
    var counter = parseInt(document.body.getAttribute(lockAttribute) || '0', 10);
    return isFinite(counter) ? counter : 0;
};
var useLockAttribute = function() {
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"]({
        "useLockAttribute.useEffect": function() {
            document.body.setAttribute(lockAttribute, (getCurrentUseCounter() + 1).toString());
            return ({
                "useLockAttribute.useEffect": function() {
                    var newCounter = getCurrentUseCounter() - 1;
                    if (newCounter <= 0) {
                        document.body.removeAttribute(lockAttribute);
                    } else {
                        document.body.setAttribute(lockAttribute, newCounter.toString());
                    }
                }
            })["useLockAttribute.useEffect"];
        }
    }["useLockAttribute.useEffect"], []);
};
var RemoveScrollBar = function(_a) {
    var noRelative = _a.noRelative, noImportant = _a.noImportant, _b = _a.gapMode, gapMode = _b === void 0 ? 'margin' : _b;
    useLockAttribute();
    /*
     gap will be measured on every component mount
     however it will be used only by the "first" invocation
     due to singleton nature of <Style
     */ var gap = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"]({
        "RemoveScrollBar.useMemo[gap]": function() {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$remove$2d$scroll$2d$bar$2f$dist$2f$es2015$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getGapWidth"])(gapMode);
        }
    }["RemoveScrollBar.useMemo[gap]"], [
        gapMode
    ]);
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"](Style, {
        styles: getStyles(gap, !noRelative, gapMode, !noImportant ? '!important' : '')
    });
};
}),
"[project]/node_modules/react-remove-scroll-bar/dist/es2015/index.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$remove$2d$scroll$2d$bar$2f$dist$2f$es2015$2f$component$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/react-remove-scroll-bar/dist/es2015/component.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$remove$2d$scroll$2d$bar$2f$dist$2f$es2015$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/react-remove-scroll-bar/dist/es2015/constants.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$remove$2d$scroll$2d$bar$2f$dist$2f$es2015$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/react-remove-scroll-bar/dist/es2015/utils.js [app-client] (ecmascript)");
;
;
;
;
}),
"[project]/node_modules/use-callback-ref/dist/es2015/assignRef.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Assigns a value for a given ref, no matter of the ref format
 * @param {RefObject} ref - a callback function or ref object
 * @param value - a new value
 *
 * @see https://github.com/theKashey/use-callback-ref#assignref
 * @example
 * const refObject = useRef();
 * const refFn = (ref) => {....}
 *
 * assignRef(refObject, "refValue");
 * assignRef(refFn, "refValue");
 */ __turbopack_context__.s([
    "assignRef",
    ()=>assignRef
]);
function assignRef(ref, value) {
    if (typeof ref === 'function') {
        ref(value);
    } else if (ref) {
        ref.current = value;
    }
    return ref;
}
}),
"[project]/node_modules/use-callback-ref/dist/es2015/useRef.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "useCallbackRef",
    ()=>useCallbackRef
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
;
function useCallbackRef(initialValue, callback) {
    var ref = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])({
        "useCallbackRef.useState": function() {
            return {
                // value
                value: initialValue,
                // last callback
                callback: callback,
                // "memoized" public interface
                facade: {
                    get current () {
                        return ref.value;
                    },
                    set current (value){
                        var last = ref.value;
                        if (last !== value) {
                            ref.value = value;
                            ref.callback(value, last);
                        }
                    }
                }
            };
        }
    }["useCallbackRef.useState"])[0];
    // update callback
    ref.callback = callback;
    return ref.facade;
}
}),
"[project]/node_modules/use-callback-ref/dist/es2015/useMergeRef.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "useMergeRefs",
    ()=>useMergeRefs
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$use$2d$callback$2d$ref$2f$dist$2f$es2015$2f$assignRef$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/use-callback-ref/dist/es2015/assignRef.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$use$2d$callback$2d$ref$2f$dist$2f$es2015$2f$useRef$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/use-callback-ref/dist/es2015/useRef.js [app-client] (ecmascript)");
;
;
;
var useIsomorphicLayoutEffect = typeof window !== 'undefined' ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useLayoutEffect"] : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"];
var currentValues = new WeakMap();
function useMergeRefs(refs, defaultValue) {
    var callbackRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$use$2d$callback$2d$ref$2f$dist$2f$es2015$2f$useRef$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallbackRef"])(defaultValue || null, {
        "useMergeRefs.useCallbackRef[callbackRef]": function(newValue) {
            return refs.forEach({
                "useMergeRefs.useCallbackRef[callbackRef]": function(ref) {
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$use$2d$callback$2d$ref$2f$dist$2f$es2015$2f$assignRef$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assignRef"])(ref, newValue);
                }
            }["useMergeRefs.useCallbackRef[callbackRef]"]);
        }
    }["useMergeRefs.useCallbackRef[callbackRef]"]);
    // handle refs changes - added or removed
    useIsomorphicLayoutEffect({
        "useMergeRefs.useIsomorphicLayoutEffect": function() {
            var oldValue = currentValues.get(callbackRef);
            if (oldValue) {
                var prevRefs_1 = new Set(oldValue);
                var nextRefs_1 = new Set(refs);
                var current_1 = callbackRef.current;
                prevRefs_1.forEach({
                    "useMergeRefs.useIsomorphicLayoutEffect": function(ref) {
                        if (!nextRefs_1.has(ref)) {
                            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$use$2d$callback$2d$ref$2f$dist$2f$es2015$2f$assignRef$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assignRef"])(ref, null);
                        }
                    }
                }["useMergeRefs.useIsomorphicLayoutEffect"]);
                nextRefs_1.forEach({
                    "useMergeRefs.useIsomorphicLayoutEffect": function(ref) {
                        if (!prevRefs_1.has(ref)) {
                            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$use$2d$callback$2d$ref$2f$dist$2f$es2015$2f$assignRef$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assignRef"])(ref, current_1);
                        }
                    }
                }["useMergeRefs.useIsomorphicLayoutEffect"]);
            }
            currentValues.set(callbackRef, refs);
        }
    }["useMergeRefs.useIsomorphicLayoutEffect"], [
        refs
    ]);
    return callbackRef;
}
}),
"[project]/node_modules/use-sidecar/dist/es2015/medium.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createMedium",
    ()=>createMedium,
    "createSidecarMedium",
    ()=>createSidecarMedium
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tslib/tslib.es6.mjs [app-client] (ecmascript)");
;
function ItoI(a) {
    return a;
}
function innerCreateMedium(defaults, middleware) {
    if (middleware === void 0) {
        middleware = ItoI;
    }
    var buffer = [];
    var assigned = false;
    var medium = {
        read: function() {
            if (assigned) {
                throw new Error('Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.');
            }
            if (buffer.length) {
                return buffer[buffer.length - 1];
            }
            return defaults;
        },
        useMedium: function(data) {
            var item = middleware(data, assigned);
            buffer.push(item);
            return function() {
                buffer = buffer.filter(function(x) {
                    return x !== item;
                });
            };
        },
        assignSyncMedium: function(cb) {
            assigned = true;
            while(buffer.length){
                var cbs = buffer;
                buffer = [];
                cbs.forEach(cb);
            }
            buffer = {
                push: function(x) {
                    return cb(x);
                },
                filter: function() {
                    return buffer;
                }
            };
        },
        assignMedium: function(cb) {
            assigned = true;
            var pendingQueue = [];
            if (buffer.length) {
                var cbs = buffer;
                buffer = [];
                cbs.forEach(cb);
                pendingQueue = buffer;
            }
            var executeQueue = function() {
                var cbs = pendingQueue;
                pendingQueue = [];
                cbs.forEach(cb);
            };
            var cycle = function() {
                return Promise.resolve().then(executeQueue);
            };
            cycle();
            buffer = {
                push: function(x) {
                    pendingQueue.push(x);
                    cycle();
                },
                filter: function(filter) {
                    pendingQueue = pendingQueue.filter(filter);
                    return buffer;
                }
            };
        }
    };
    return medium;
}
function createMedium(defaults, middleware) {
    if (middleware === void 0) {
        middleware = ItoI;
    }
    return innerCreateMedium(defaults, middleware);
}
function createSidecarMedium(options) {
    if (options === void 0) {
        options = {};
    }
    var medium = innerCreateMedium(null);
    medium.options = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__assign"])({
        async: true,
        ssr: false
    }, options);
    return medium;
}
}),
"[project]/node_modules/use-sidecar/dist/es2015/exports.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "exportSidecar",
    ()=>exportSidecar
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tslib/tslib.es6.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
;
;
var SideCar = function(_a) {
    var sideCar = _a.sideCar, rest = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__rest"])(_a, [
        "sideCar"
    ]);
    if (!sideCar) {
        throw new Error('Sidecar: please provide `sideCar` property to import the right car');
    }
    var Target = sideCar.read();
    if (!Target) {
        throw new Error('Sidecar medium not found');
    }
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"](Target, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__assign"])({}, rest));
};
SideCar.isSideCarExport = true;
function exportSidecar(medium, exported) {
    medium.useMedium(exported);
    return SideCar;
}
}),
"[project]/node_modules/react-remove-scroll/dist/es2015/medium.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "effectCar",
    ()=>effectCar
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$use$2d$sidecar$2f$dist$2f$es2015$2f$medium$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/use-sidecar/dist/es2015/medium.js [app-client] (ecmascript)");
;
var effectCar = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$use$2d$sidecar$2f$dist$2f$es2015$2f$medium$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createSidecarMedium"])();
}),
"[project]/node_modules/react-remove-scroll/dist/es2015/UI.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "RemoveScroll",
    ()=>RemoveScroll
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tslib/tslib.es6.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$remove$2d$scroll$2d$bar$2f$dist$2f$es2015$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/react-remove-scroll-bar/dist/es2015/constants.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$use$2d$callback$2d$ref$2f$dist$2f$es2015$2f$useMergeRef$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/use-callback-ref/dist/es2015/useMergeRef.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$remove$2d$scroll$2f$dist$2f$es2015$2f$medium$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/react-remove-scroll/dist/es2015/medium.js [app-client] (ecmascript)");
;
;
;
;
;
var nothing = function() {
    return;
};
/**
 * Removes scrollbar from the page and contain the scroll within the Lock
 */ var RemoveScroll = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["forwardRef"](function(props, parentRef) {
    var ref = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"](null);
    var _a = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"]({
        onScrollCapture: nothing,
        onWheelCapture: nothing,
        onTouchMoveCapture: nothing
    }), callbacks = _a[0], setCallbacks = _a[1];
    var forwardProps = props.forwardProps, children = props.children, className = props.className, removeScrollBar = props.removeScrollBar, enabled = props.enabled, shards = props.shards, sideCar = props.sideCar, noRelative = props.noRelative, noIsolation = props.noIsolation, inert = props.inert, allowPinchZoom = props.allowPinchZoom, _b = props.as, Container = _b === void 0 ? 'div' : _b, gapMode = props.gapMode, rest = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__rest"])(props, [
        "forwardProps",
        "children",
        "className",
        "removeScrollBar",
        "enabled",
        "shards",
        "sideCar",
        "noRelative",
        "noIsolation",
        "inert",
        "allowPinchZoom",
        "as",
        "gapMode"
    ]);
    var SideCar = sideCar;
    var containerRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$use$2d$callback$2d$ref$2f$dist$2f$es2015$2f$useMergeRef$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMergeRefs"])([
        ref,
        parentRef
    ]);
    var containerProps = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__assign"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__assign"])({}, rest), callbacks);
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Fragment"], null, enabled && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"](SideCar, {
        sideCar: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$remove$2d$scroll$2f$dist$2f$es2015$2f$medium$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["effectCar"],
        removeScrollBar: removeScrollBar,
        shards: shards,
        noRelative: noRelative,
        noIsolation: noIsolation,
        inert: inert,
        setCallbacks: setCallbacks,
        allowPinchZoom: !!allowPinchZoom,
        lockRef: ref,
        gapMode: gapMode
    }), forwardProps ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cloneElement"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Children"].only(children), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__assign"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__assign"])({}, containerProps), {
        ref: containerRef
    })) : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"](Container, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__assign"])({}, containerProps, {
        className: className,
        ref: containerRef
    }), children));
});
RemoveScroll.defaultProps = {
    enabled: true,
    removeScrollBar: true,
    inert: false
};
RemoveScroll.classNames = {
    fullWidth: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$remove$2d$scroll$2d$bar$2f$dist$2f$es2015$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fullWidthClassName"],
    zeroRight: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$remove$2d$scroll$2d$bar$2f$dist$2f$es2015$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["zeroRightClassName"]
};
;
}),
"[project]/node_modules/react-remove-scroll/dist/es2015/aggresiveCapture.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "nonPassive",
    ()=>nonPassive
]);
var passiveSupported = false;
if (typeof window !== 'undefined') {
    try {
        var options = Object.defineProperty({}, 'passive', {
            get: function() {
                passiveSupported = true;
                return true;
            }
        });
        // @ts-ignore
        window.addEventListener('test', options, options);
        // @ts-ignore
        window.removeEventListener('test', options, options);
    } catch (err) {
        passiveSupported = false;
    }
}
var nonPassive = passiveSupported ? {
    passive: false
} : false;
}),
"[project]/node_modules/react-remove-scroll/dist/es2015/handleScroll.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "handleScroll",
    ()=>handleScroll,
    "locationCouldBeScrolled",
    ()=>locationCouldBeScrolled
]);
var alwaysContainsScroll = function(node) {
    // textarea will always _contain_ scroll inside self. It only can be hidden
    return node.tagName === 'TEXTAREA';
};
var elementCanBeScrolled = function(node, overflow) {
    if (!(node instanceof Element)) {
        return false;
    }
    var styles = window.getComputedStyle(node);
    return(// not-not-scrollable
    styles[overflow] !== 'hidden' && // contains scroll inside self
    !(styles.overflowY === styles.overflowX && !alwaysContainsScroll(node) && styles[overflow] === 'visible'));
};
var elementCouldBeVScrolled = function(node) {
    return elementCanBeScrolled(node, 'overflowY');
};
var elementCouldBeHScrolled = function(node) {
    return elementCanBeScrolled(node, 'overflowX');
};
var locationCouldBeScrolled = function(axis, node) {
    var ownerDocument = node.ownerDocument;
    var current = node;
    do {
        // Skip over shadow root
        if (typeof ShadowRoot !== 'undefined' && current instanceof ShadowRoot) {
            current = current.host;
        }
        var isScrollable = elementCouldBeScrolled(axis, current);
        if (isScrollable) {
            var _a = getScrollVariables(axis, current), scrollHeight = _a[1], clientHeight = _a[2];
            if (scrollHeight > clientHeight) {
                return true;
            }
        }
        current = current.parentNode;
    }while (current && current !== ownerDocument.body)
    return false;
};
var getVScrollVariables = function(_a) {
    var scrollTop = _a.scrollTop, scrollHeight = _a.scrollHeight, clientHeight = _a.clientHeight;
    return [
        scrollTop,
        scrollHeight,
        clientHeight
    ];
};
var getHScrollVariables = function(_a) {
    var scrollLeft = _a.scrollLeft, scrollWidth = _a.scrollWidth, clientWidth = _a.clientWidth;
    return [
        scrollLeft,
        scrollWidth,
        clientWidth
    ];
};
var elementCouldBeScrolled = function(axis, node) {
    return axis === 'v' ? elementCouldBeVScrolled(node) : elementCouldBeHScrolled(node);
};
var getScrollVariables = function(axis, node) {
    return axis === 'v' ? getVScrollVariables(node) : getHScrollVariables(node);
};
var getDirectionFactor = function(axis, direction) {
    /**
     * If the element's direction is rtl (right-to-left), then scrollLeft is 0 when the scrollbar is at its rightmost position,
     * and then increasingly negative as you scroll towards the end of the content.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollLeft
     */ return axis === 'h' && direction === 'rtl' ? -1 : 1;
};
var handleScroll = function(axis, endTarget, event, sourceDelta, noOverscroll) {
    var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction);
    var delta = directionFactor * sourceDelta;
    // find scrollable target
    var target = event.target;
    var targetInLock = endTarget.contains(target);
    var shouldCancelScroll = false;
    var isDeltaPositive = delta > 0;
    var availableScroll = 0;
    var availableScrollTop = 0;
    do {
        if (!target) {
            break;
        }
        var _a = getScrollVariables(axis, target), position = _a[0], scroll_1 = _a[1], capacity = _a[2];
        var elementScroll = scroll_1 - capacity - directionFactor * position;
        if (position || elementScroll) {
            if (elementCouldBeScrolled(axis, target)) {
                availableScroll += elementScroll;
                availableScrollTop += position;
            }
        }
        var parent_1 = target.parentNode;
        // we will "bubble" from ShadowDom in case we are, or just to the parent in normal case
        // this is the same logic used in focus-lock
        target = parent_1 && parent_1.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? parent_1.host : parent_1;
    }while (// portaled content
    !targetInLock && target !== document.body || targetInLock && (endTarget.contains(target) || endTarget === target))
    // handle epsilon around 0 (non standard zoom levels)
    if (isDeltaPositive && (noOverscroll && Math.abs(availableScroll) < 1 || !noOverscroll && delta > availableScroll)) {
        shouldCancelScroll = true;
    } else if (!isDeltaPositive && (noOverscroll && Math.abs(availableScrollTop) < 1 || !noOverscroll && -delta > availableScrollTop)) {
        shouldCancelScroll = true;
    }
    return shouldCancelScroll;
};
}),
"[project]/node_modules/react-remove-scroll/dist/es2015/SideEffect.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "RemoveScrollSideCar",
    ()=>RemoveScrollSideCar,
    "getDeltaXY",
    ()=>getDeltaXY,
    "getTouchXY",
    ()=>getTouchXY
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tslib/tslib.es6.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$remove$2d$scroll$2d$bar$2f$dist$2f$es2015$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/react-remove-scroll-bar/dist/es2015/index.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$remove$2d$scroll$2d$bar$2f$dist$2f$es2015$2f$component$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/react-remove-scroll-bar/dist/es2015/component.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$style$2d$singleton$2f$dist$2f$es2015$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/react-style-singleton/dist/es2015/index.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$style$2d$singleton$2f$dist$2f$es2015$2f$component$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/react-style-singleton/dist/es2015/component.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$remove$2d$scroll$2f$dist$2f$es2015$2f$aggresiveCapture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/react-remove-scroll/dist/es2015/aggresiveCapture.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$remove$2d$scroll$2f$dist$2f$es2015$2f$handleScroll$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/react-remove-scroll/dist/es2015/handleScroll.js [app-client] (ecmascript)");
;
;
;
;
;
;
var getTouchXY = function(event) {
    return 'changedTouches' in event ? [
        event.changedTouches[0].clientX,
        event.changedTouches[0].clientY
    ] : [
        0,
        0
    ];
};
var getDeltaXY = function(event) {
    return [
        event.deltaX,
        event.deltaY
    ];
};
var extractRef = function(ref) {
    return ref && 'current' in ref ? ref.current : ref;
};
var deltaCompare = function(x, y) {
    return x[0] === y[0] && x[1] === y[1];
};
var generateStyle = function(id) {
    return "\n  .block-interactivity-".concat(id, " {pointer-events: none;}\n  .allow-interactivity-").concat(id, " {pointer-events: all;}\n");
};
var idCounter = 0;
var lockStack = [];
function RemoveScrollSideCar(props) {
    var shouldPreventQueue = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"]([]);
    var touchStartRef = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"]([
        0,
        0
    ]);
    var activeAxis = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"]();
    var id = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"](idCounter++)[0];
    var Style = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$style$2d$singleton$2f$dist$2f$es2015$2f$component$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["styleSingleton"])[0];
    var lastProps = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"](props);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"]({
        "RemoveScrollSideCar.useEffect": function() {
            lastProps.current = props;
        }
    }["RemoveScrollSideCar.useEffect"], [
        props
    ]);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"]({
        "RemoveScrollSideCar.useEffect": function() {
            if (props.inert) {
                document.body.classList.add("block-interactivity-".concat(id));
                var allow_1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__spreadArray"])([
                    props.lockRef.current
                ], (props.shards || []).map(extractRef), true).filter(Boolean);
                allow_1.forEach({
                    "RemoveScrollSideCar.useEffect": function(el) {
                        return el.classList.add("allow-interactivity-".concat(id));
                    }
                }["RemoveScrollSideCar.useEffect"]);
                return ({
                    "RemoveScrollSideCar.useEffect": function() {
                        document.body.classList.remove("block-interactivity-".concat(id));
                        allow_1.forEach({
                            "RemoveScrollSideCar.useEffect": function(el) {
                                return el.classList.remove("allow-interactivity-".concat(id));
                            }
                        }["RemoveScrollSideCar.useEffect"]);
                    }
                })["RemoveScrollSideCar.useEffect"];
            }
            return;
        }
    }["RemoveScrollSideCar.useEffect"], [
        props.inert,
        props.lockRef.current,
        props.shards
    ]);
    var shouldCancelEvent = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"]({
        "RemoveScrollSideCar.useCallback[shouldCancelEvent]": function(event, parent) {
            if ('touches' in event && event.touches.length === 2 || event.type === 'wheel' && event.ctrlKey) {
                return !lastProps.current.allowPinchZoom;
            }
            var touch = getTouchXY(event);
            var touchStart = touchStartRef.current;
            var deltaX = 'deltaX' in event ? event.deltaX : touchStart[0] - touch[0];
            var deltaY = 'deltaY' in event ? event.deltaY : touchStart[1] - touch[1];
            var currentAxis;
            var target = event.target;
            var moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? 'h' : 'v';
            // allow horizontal touch move on Range inputs. They will not cause any scroll
            if ('touches' in event && moveDirection === 'h' && target.type === 'range') {
                return false;
            }
            var canBeScrolledInMainDirection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$remove$2d$scroll$2f$dist$2f$es2015$2f$handleScroll$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["locationCouldBeScrolled"])(moveDirection, target);
            if (!canBeScrolledInMainDirection) {
                return true;
            }
            if (canBeScrolledInMainDirection) {
                currentAxis = moveDirection;
            } else {
                currentAxis = moveDirection === 'v' ? 'h' : 'v';
                canBeScrolledInMainDirection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$remove$2d$scroll$2f$dist$2f$es2015$2f$handleScroll$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["locationCouldBeScrolled"])(moveDirection, target);
            // other axis might be not scrollable
            }
            if (!canBeScrolledInMainDirection) {
                return false;
            }
            if (!activeAxis.current && 'changedTouches' in event && (deltaX || deltaY)) {
                activeAxis.current = currentAxis;
            }
            if (!currentAxis) {
                return true;
            }
            var cancelingAxis = activeAxis.current || currentAxis;
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$remove$2d$scroll$2f$dist$2f$es2015$2f$handleScroll$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["handleScroll"])(cancelingAxis, parent, event, cancelingAxis === 'h' ? deltaX : deltaY, true);
        }
    }["RemoveScrollSideCar.useCallback[shouldCancelEvent]"], []);
    var shouldPrevent = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"]({
        "RemoveScrollSideCar.useCallback[shouldPrevent]": function(_event) {
            var event = _event;
            if (!lockStack.length || lockStack[lockStack.length - 1] !== Style) {
                // not the last active
                return;
            }
            var delta = 'deltaY' in event ? getDeltaXY(event) : getTouchXY(event);
            var sourceEvent = shouldPreventQueue.current.filter({
                "RemoveScrollSideCar.useCallback[shouldPrevent]": function(e) {
                    return e.name === event.type && (e.target === event.target || event.target === e.shadowParent) && deltaCompare(e.delta, delta);
                }
            }["RemoveScrollSideCar.useCallback[shouldPrevent]"])[0];
            // self event, and should be canceled
            if (sourceEvent && sourceEvent.should) {
                if (event.cancelable) {
                    event.preventDefault();
                }
                return;
            }
            // outside or shard event
            if (!sourceEvent) {
                var shardNodes = (lastProps.current.shards || []).map(extractRef).filter(Boolean).filter({
                    "RemoveScrollSideCar.useCallback[shouldPrevent].shardNodes": function(node) {
                        return node.contains(event.target);
                    }
                }["RemoveScrollSideCar.useCallback[shouldPrevent].shardNodes"]);
                var shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;
                if (shouldStop) {
                    if (event.cancelable) {
                        event.preventDefault();
                    }
                }
            }
        }
    }["RemoveScrollSideCar.useCallback[shouldPrevent]"], []);
    var shouldCancel = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"]({
        "RemoveScrollSideCar.useCallback[shouldCancel]": function(name, delta, target, should) {
            var event = {
                name: name,
                delta: delta,
                target: target,
                should: should,
                shadowParent: getOutermostShadowParent(target)
            };
            shouldPreventQueue.current.push(event);
            setTimeout({
                "RemoveScrollSideCar.useCallback[shouldCancel]": function() {
                    shouldPreventQueue.current = shouldPreventQueue.current.filter({
                        "RemoveScrollSideCar.useCallback[shouldCancel]": function(e) {
                            return e !== event;
                        }
                    }["RemoveScrollSideCar.useCallback[shouldCancel]"]);
                }
            }["RemoveScrollSideCar.useCallback[shouldCancel]"], 1);
        }
    }["RemoveScrollSideCar.useCallback[shouldCancel]"], []);
    var scrollTouchStart = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"]({
        "RemoveScrollSideCar.useCallback[scrollTouchStart]": function(event) {
            touchStartRef.current = getTouchXY(event);
            activeAxis.current = undefined;
        }
    }["RemoveScrollSideCar.useCallback[scrollTouchStart]"], []);
    var scrollWheel = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"]({
        "RemoveScrollSideCar.useCallback[scrollWheel]": function(event) {
            shouldCancel(event.type, getDeltaXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
        }
    }["RemoveScrollSideCar.useCallback[scrollWheel]"], []);
    var scrollTouchMove = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"]({
        "RemoveScrollSideCar.useCallback[scrollTouchMove]": function(event) {
            shouldCancel(event.type, getTouchXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
        }
    }["RemoveScrollSideCar.useCallback[scrollTouchMove]"], []);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"]({
        "RemoveScrollSideCar.useEffect": function() {
            lockStack.push(Style);
            props.setCallbacks({
                onScrollCapture: scrollWheel,
                onWheelCapture: scrollWheel,
                onTouchMoveCapture: scrollTouchMove
            });
            document.addEventListener('wheel', shouldPrevent, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$remove$2d$scroll$2f$dist$2f$es2015$2f$aggresiveCapture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["nonPassive"]);
            document.addEventListener('touchmove', shouldPrevent, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$remove$2d$scroll$2f$dist$2f$es2015$2f$aggresiveCapture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["nonPassive"]);
            document.addEventListener('touchstart', scrollTouchStart, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$remove$2d$scroll$2f$dist$2f$es2015$2f$aggresiveCapture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["nonPassive"]);
            return ({
                "RemoveScrollSideCar.useEffect": function() {
                    lockStack = lockStack.filter({
                        "RemoveScrollSideCar.useEffect": function(inst) {
                            return inst !== Style;
                        }
                    }["RemoveScrollSideCar.useEffect"]);
                    document.removeEventListener('wheel', shouldPrevent, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$remove$2d$scroll$2f$dist$2f$es2015$2f$aggresiveCapture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["nonPassive"]);
                    document.removeEventListener('touchmove', shouldPrevent, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$remove$2d$scroll$2f$dist$2f$es2015$2f$aggresiveCapture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["nonPassive"]);
                    document.removeEventListener('touchstart', scrollTouchStart, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$remove$2d$scroll$2f$dist$2f$es2015$2f$aggresiveCapture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["nonPassive"]);
                }
            })["RemoveScrollSideCar.useEffect"];
        }
    }["RemoveScrollSideCar.useEffect"], []);
    var removeScrollBar = props.removeScrollBar, inert = props.inert;
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Fragment"], null, inert ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"](Style, {
        styles: generateStyle(id)
    }) : null, removeScrollBar ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$remove$2d$scroll$2d$bar$2f$dist$2f$es2015$2f$component$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RemoveScrollBar"], {
        noRelative: props.noRelative,
        gapMode: props.gapMode
    }) : null);
}
function getOutermostShadowParent(node) {
    var shadowParent = null;
    while(node !== null){
        if (node instanceof ShadowRoot) {
            shadowParent = node.host;
            node = node.host;
        }
        node = node.parentNode;
    }
    return shadowParent;
}
}),
"[project]/node_modules/react-remove-scroll/dist/es2015/sidecar.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$use$2d$sidecar$2f$dist$2f$es2015$2f$exports$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/use-sidecar/dist/es2015/exports.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$remove$2d$scroll$2f$dist$2f$es2015$2f$SideEffect$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/react-remove-scroll/dist/es2015/SideEffect.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$remove$2d$scroll$2f$dist$2f$es2015$2f$medium$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/react-remove-scroll/dist/es2015/medium.js [app-client] (ecmascript)");
;
;
;
const __TURBOPACK__default__export__ = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$use$2d$sidecar$2f$dist$2f$es2015$2f$exports$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["exportSidecar"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$remove$2d$scroll$2f$dist$2f$es2015$2f$medium$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["effectCar"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$remove$2d$scroll$2f$dist$2f$es2015$2f$SideEffect$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RemoveScrollSideCar"]);
}),
"[project]/node_modules/react-remove-scroll/dist/es2015/Combination.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tslib/tslib.es6.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$remove$2d$scroll$2f$dist$2f$es2015$2f$UI$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/react-remove-scroll/dist/es2015/UI.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$remove$2d$scroll$2f$dist$2f$es2015$2f$sidecar$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/react-remove-scroll/dist/es2015/sidecar.js [app-client] (ecmascript)");
;
;
;
;
var ReactRemoveScroll = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["forwardRef"](function(props, ref) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$remove$2d$scroll$2f$dist$2f$es2015$2f$UI$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RemoveScroll"], (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__assign"])({}, props, {
        ref: ref,
        sideCar: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$remove$2d$scroll$2f$dist$2f$es2015$2f$sidecar$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]
    }));
});
ReactRemoveScroll.classNames = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$remove$2d$scroll$2f$dist$2f$es2015$2f$UI$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RemoveScroll"].classNames;
const __TURBOPACK__default__export__ = ReactRemoveScroll;
}),
"[project]/node_modules/react-remove-scroll/dist/es2015/Combination.js [app-client] (ecmascript) <export default as RemoveScroll>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "RemoveScroll",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$remove$2d$scroll$2f$dist$2f$es2015$2f$Combination$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$remove$2d$scroll$2f$dist$2f$es2015$2f$Combination$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/react-remove-scroll/dist/es2015/Combination.js [app-client] (ecmascript)");
}),
"[project]/node_modules/get-nonce/dist/es2015/index.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getNonce",
    ()=>getNonce,
    "setNonce",
    ()=>setNonce
]);
var currentNonce;
var setNonce = function(nonce) {
    currentNonce = nonce;
};
var getNonce = function() {
    if (currentNonce) {
        return currentNonce;
    }
    if (typeof __webpack_nonce__ !== 'undefined') {
        return __webpack_nonce__;
    }
    return undefined;
};
}),
"[project]/node_modules/react-style-singleton/dist/es2015/singleton.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "stylesheetSingleton",
    ()=>stylesheetSingleton
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$get$2d$nonce$2f$dist$2f$es2015$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/get-nonce/dist/es2015/index.js [app-client] (ecmascript)");
;
function makeStyleTag() {
    if (!document) return null;
    var tag = document.createElement('style');
    tag.type = 'text/css';
    var nonce = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$get$2d$nonce$2f$dist$2f$es2015$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getNonce"])();
    if (nonce) {
        tag.setAttribute('nonce', nonce);
    }
    return tag;
}
function injectStyles(tag, css) {
    // @ts-ignore
    if (tag.styleSheet) {
        // @ts-ignore
        tag.styleSheet.cssText = css;
    } else {
        tag.appendChild(document.createTextNode(css));
    }
}
function insertStyleTag(tag) {
    var head = document.head || document.getElementsByTagName('head')[0];
    head.appendChild(tag);
}
var stylesheetSingleton = function() {
    var counter = 0;
    var stylesheet = null;
    return {
        add: function(style) {
            if (counter == 0) {
                if (stylesheet = makeStyleTag()) {
                    injectStyles(stylesheet, style);
                    insertStyleTag(stylesheet);
                }
            }
            counter++;
        },
        remove: function() {
            counter--;
            if (!counter && stylesheet) {
                stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet);
                stylesheet = null;
            }
        }
    };
};
}),
"[project]/node_modules/react-style-singleton/dist/es2015/hook.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "styleHookSingleton",
    ()=>styleHookSingleton
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$style$2d$singleton$2f$dist$2f$es2015$2f$singleton$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/react-style-singleton/dist/es2015/singleton.js [app-client] (ecmascript)");
;
;
var styleHookSingleton = function() {
    var sheet = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$style$2d$singleton$2f$dist$2f$es2015$2f$singleton$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["stylesheetSingleton"])();
    return function(styles, isDynamic) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"]({
            "styleHookSingleton.useEffect": function() {
                sheet.add(styles);
                return ({
                    "styleHookSingleton.useEffect": function() {
                        sheet.remove();
                    }
                })["styleHookSingleton.useEffect"];
            }
        }["styleHookSingleton.useEffect"], [
            styles && isDynamic
        ]);
    };
};
}),
"[project]/node_modules/react-style-singleton/dist/es2015/component.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "styleSingleton",
    ()=>styleSingleton
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$style$2d$singleton$2f$dist$2f$es2015$2f$hook$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/react-style-singleton/dist/es2015/hook.js [app-client] (ecmascript)");
;
var styleSingleton = function() {
    var useStyle = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$style$2d$singleton$2f$dist$2f$es2015$2f$hook$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["styleHookSingleton"])();
    var Sheet = function(_a) {
        var styles = _a.styles, dynamic = _a.dynamic;
        useStyle(styles, dynamic);
        return null;
    };
    return Sheet;
};
}),
"[project]/node_modules/react-style-singleton/dist/es2015/index.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$style$2d$singleton$2f$dist$2f$es2015$2f$component$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/react-style-singleton/dist/es2015/component.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$style$2d$singleton$2f$dist$2f$es2015$2f$singleton$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/react-style-singleton/dist/es2015/singleton.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$style$2d$singleton$2f$dist$2f$es2015$2f$hook$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/react-style-singleton/dist/es2015/hook.js [app-client] (ecmascript)");
;
;
;
}),
"[project]/node_modules/aria-hidden/dist/es2015/index.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "hideOthers",
    ()=>hideOthers,
    "inertOthers",
    ()=>inertOthers,
    "supportsInert",
    ()=>supportsInert,
    "suppressOthers",
    ()=>suppressOthers
]);
var getDefaultParent = function(originalTarget) {
    if (typeof document === 'undefined') {
        return null;
    }
    var sampleTarget = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
    return sampleTarget.ownerDocument.body;
};
var counterMap = new WeakMap();
var uncontrolledNodes = new WeakMap();
var markerMap = {};
var lockCount = 0;
var unwrapHost = function(node) {
    return node && (node.host || unwrapHost(node.parentNode));
};
var correctTargets = function(parent, targets) {
    return targets.map(function(target) {
        if (parent.contains(target)) {
            return target;
        }
        var correctedTarget = unwrapHost(target);
        if (correctedTarget && parent.contains(correctedTarget)) {
            return correctedTarget;
        }
        console.error('aria-hidden', target, 'in not contained inside', parent, '. Doing nothing');
        return null;
    }).filter(function(x) {
        return Boolean(x);
    });
};
/**
 * Marks everything except given node(or nodes) as aria-hidden
 * @param {Element | Element[]} originalTarget - elements to keep on the page
 * @param [parentNode] - top element, defaults to document.body
 * @param {String} [markerName] - a special attribute to mark every node
 * @param {String} [controlAttribute] - html Attribute to control
 * @return {Undo} undo command
 */ var applyAttributeToOthers = function(originalTarget, parentNode, markerName, controlAttribute) {
    var targets = correctTargets(parentNode, Array.isArray(originalTarget) ? originalTarget : [
        originalTarget
    ]);
    if (!markerMap[markerName]) {
        markerMap[markerName] = new WeakMap();
    }
    var markerCounter = markerMap[markerName];
    var hiddenNodes = [];
    var elementsToKeep = new Set();
    var elementsToStop = new Set(targets);
    var keep = function(el) {
        if (!el || elementsToKeep.has(el)) {
            return;
        }
        elementsToKeep.add(el);
        keep(el.parentNode);
    };
    targets.forEach(keep);
    var deep = function(parent) {
        if (!parent || elementsToStop.has(parent)) {
            return;
        }
        Array.prototype.forEach.call(parent.children, function(node) {
            if (elementsToKeep.has(node)) {
                deep(node);
            } else {
                try {
                    var attr = node.getAttribute(controlAttribute);
                    var alreadyHidden = attr !== null && attr !== 'false';
                    var counterValue = (counterMap.get(node) || 0) + 1;
                    var markerValue = (markerCounter.get(node) || 0) + 1;
                    counterMap.set(node, counterValue);
                    markerCounter.set(node, markerValue);
                    hiddenNodes.push(node);
                    if (counterValue === 1 && alreadyHidden) {
                        uncontrolledNodes.set(node, true);
                    }
                    if (markerValue === 1) {
                        node.setAttribute(markerName, 'true');
                    }
                    if (!alreadyHidden) {
                        node.setAttribute(controlAttribute, 'true');
                    }
                } catch (e) {
                    console.error('aria-hidden: cannot operate on ', node, e);
                }
            }
        });
    };
    deep(parentNode);
    elementsToKeep.clear();
    lockCount++;
    return function() {
        hiddenNodes.forEach(function(node) {
            var counterValue = counterMap.get(node) - 1;
            var markerValue = markerCounter.get(node) - 1;
            counterMap.set(node, counterValue);
            markerCounter.set(node, markerValue);
            if (!counterValue) {
                if (!uncontrolledNodes.has(node)) {
                    node.removeAttribute(controlAttribute);
                }
                uncontrolledNodes.delete(node);
            }
            if (!markerValue) {
                node.removeAttribute(markerName);
            }
        });
        lockCount--;
        if (!lockCount) {
            // clear
            counterMap = new WeakMap();
            counterMap = new WeakMap();
            uncontrolledNodes = new WeakMap();
            markerMap = {};
        }
    };
};
var hideOthers = function(originalTarget, parentNode, markerName) {
    if (markerName === void 0) {
        markerName = 'data-aria-hidden';
    }
    var targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [
        originalTarget
    ]);
    var activeParentNode = parentNode || getDefaultParent(originalTarget);
    if (!activeParentNode) {
        return function() {
            return null;
        };
    }
    // we should not hide aria-live elements - https://github.com/theKashey/aria-hidden/issues/10
    // and script elements, as they have no impact on accessibility.
    targets.push.apply(targets, Array.from(activeParentNode.querySelectorAll('[aria-live], script')));
    return applyAttributeToOthers(targets, activeParentNode, markerName, 'aria-hidden');
};
var inertOthers = function(originalTarget, parentNode, markerName) {
    if (markerName === void 0) {
        markerName = 'data-inert-ed';
    }
    var activeParentNode = parentNode || getDefaultParent(originalTarget);
    if (!activeParentNode) {
        return function() {
            return null;
        };
    }
    return applyAttributeToOthers(originalTarget, activeParentNode, markerName, 'inert');
};
var supportsInert = function() {
    return typeof HTMLElement !== 'undefined' && HTMLElement.prototype.hasOwnProperty('inert');
};
var suppressOthers = function(originalTarget, parentNode, markerName) {
    if (markerName === void 0) {
        markerName = 'data-suppressed';
    }
    return (supportsInert() ? inertOthers : hideOthers)(originalTarget, parentNode, markerName);
};
}),
"[project]/node_modules/@ably/chat/dist/chat/ably-chat.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ChatClient",
    ()=>Xr,
    "ChatMessageAction",
    ()=>R,
    "ChatMessageEventType",
    ()=>P,
    "ConnectionStatus",
    ()=>ur,
    "ErrorCode",
    ()=>B,
    "LogLevel",
    ()=>At,
    "MessageReactionEventType",
    ()=>M,
    "MessageReactionType",
    ()=>z,
    "OccupancyEventType",
    ()=>Oe,
    "OrderBy",
    ()=>Ie,
    "PresenceEventType",
    ()=>dr,
    "RoomEventType",
    ()=>J,
    "RoomStatus",
    ()=>f,
    "TypingEventType",
    ()=>T,
    "TypingSetEventType",
    ()=>k,
    "errorInfoIs",
    ()=>Jr
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ably$2f$build$2f$ably$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ably/build/ably.js [app-client] (ecmascript)");
;
var At = /* @__PURE__ */ ((n)=>(n.Trace = "trace", n.Debug = "debug", n.Info = "info", n.Warn = "warn", n.Error = "error", n.Silent = "silent", n))(At || {});
const ir = (n, e, t)=>{
    const r = t ? `, context: ${JSON.stringify(t)}` : "", i = `[${/* @__PURE__ */ new Date().toISOString()}] ${e.valueOf().toUpperCase()} ably-chat: ${n}${r}`;
    switch(e){
        case "trace":
        case "debug":
            {
                console.log(i);
                break;
            }
        case "info":
            {
                console.info(i);
                break;
            }
        case "warn":
            {
                console.warn(i);
                break;
            }
        case "error":
            {
                console.error(i);
                break;
            }
    }
}, ar = (n)=>{
    const e = n.logHandler ?? ir;
    return new De(e, n.logLevel);
}, bt = /* @__PURE__ */ new Map([
    [
        "trace",
        0
    ],
    [
        "debug",
        1
    ],
    [
        "info",
        2
    ],
    [
        "warn",
        3
    ],
    [
        "error",
        4
    ],
    [
        "silent",
        5
    ]
]);
class De {
    constructor(e, t, r){
        this._handler = e, this._context = r;
        const i = bt.get(t);
        if (i === void 0) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ably$2f$build$2f$ably$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ErrorInfo"](`Invalid log level: ${t}`, 5e4, 500);
        this._levelNumber = i;
    }
    trace(e, t) {
        this._write(e, "trace", 0, t);
    }
    debug(e, t) {
        this._write(e, "debug", 1, t);
    }
    info(e, t) {
        this._write(e, "info", 2, t);
    }
    warn(e, t) {
        this._write(e, "warn", 3, t);
    }
    error(e, t) {
        this._write(e, "error", 4, t);
    }
    withContext(e) {
        const t = [
            ...bt.entries()
        ].find(([, r])=>r === this._levelNumber)?.[0] ?? "error";
        return new De(this._handler, t, this._mergeContext(e));
    }
    _write(e, t, r, i) {
        r >= this._levelNumber && this._handler(e, t, this._mergeContext(i));
    }
    _mergeContext(e) {
        return this._context ? e ? {
            ...this._context,
            ...e
        } : this._context : e ?? void 0;
    }
}
const or = {
    logLevel: At.Error
}, cr = (n)=>(n = n ?? {}, {
        ...n,
        logLevel: n.logLevel ?? or.logLevel
    });
function L(n, e, t) {
    if ((Array.isArray(e) || typeof e == "string") && t) return n.on(e, t), ()=>{
        n.off(t);
    };
    if (typeof e == "function") return n.on(e), ()=>{
        n.off(e);
    };
    throw new TypeError("Invalid arguments passed to on()");
}
function hr(n, e, t) {
    if (t) return n.once(e, t), ()=>{
        n.off(t);
    };
    throw new TypeError("Invalid arguments passed to once()");
}
function F(n, e, t) {
    if ((Array.isArray(e) || typeof e == "string") && t) {
        const r = n.subscribe(e, t);
        return ()=>{
            r.then(()=>{
                n.unsubscribe(t);
            }).catch((i)=>{
                console.error("Error subscribing to events:", i);
            });
        };
    } else if (typeof e == "function") {
        const r = n.subscribe(e);
        return ()=>{
            r.then(()=>{
                n.unsubscribe(e);
            }).catch((i)=>{
                console.error("Error subscribing to events:", i);
            });
        };
    } else throw new TypeError("Invalid arguments passed to subscribe()");
}
const lr = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ably$2f$build$2f$ably$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Realtime"].EventEmitter;
class A extends lr {
}
const v = (n)=>(...e)=>n(...e), N = (n)=>{
    const e = n, t = Object.values(e.events).flat().length + e.any.length + Object.values(e.eventsOnce).flat().length + e.anyOnce.length;
    return t ? t > 0 : !1;
};
var ur = /* @__PURE__ */ ((n)=>(n.Initialized = "initialized", n.Connecting = "connecting", n.Connected = "connected", n.Disconnected = "disconnected", n.Suspended = "suspended", n.Failed = "failed", n))(ur || {});
class gr {
    /**
   * Constructs a new `DefaultConnection` instance.
   * @param ably The Ably Realtime client.
   * @param logger The logger to use.
   */ constructor(e, t){
        this._status = "initialized", this._emitter = new A(), this._logger = t, this._status = this._mapAblyStatusToChat(e.connection.state), this._error = e.connection.errorReason;
        const r = (i)=>{
            const c = this._mapAblyStatusToChat(i.current);
            if (c === this._status) return;
            const l = {
                current: c,
                previous: this._status,
                error: i.reason,
                retryIn: i.retryIn
            };
            this._applyStatusChange(l);
        };
        this._clearAblyConnectionListener = L(e.connection, r);
    }
    /**
   * @inheritdoc
   */ get status() {
        return this._status;
    }
    /**
   * @inheritdoc
   */ get error() {
        return this._error;
    }
    /**
   * @inheritdoc
   */ onStatusChange(e) {
        const t = v(e);
        return this._emitter.on(t), {
            off: ()=>{
                this._emitter.off(t);
            }
        };
    }
    /**
   * @inheritdoc
   */ dispose() {
        this._logger.trace("DefaultConnection.dispose();"), this._clearAblyConnectionListener(), this._emitter.off();
    }
    /**
   * Checks if there are any listeners registered on the connection.
   * @internal
   * @returns true if there are listeners, false otherwise.
   */ hasListeners() {
        return N(this._emitter);
    }
    _applyStatusChange(e) {
        this._status = e.current, this._error = e.error, this._logger.info("Connection state changed", e), this._emitter.emit(e.current, e);
    }
    _mapAblyStatusToChat(e) {
        switch(e){
            case "closing":
            case "closed":
                return "failed";
            default:
                return e;
        }
    }
}
const Et = ()=>Math.random().toString(36).slice(2);
var wt = Object.prototype.hasOwnProperty;
function St(n, e, t) {
    for (t of n.keys())if (Y(t, e)) return t;
}
function Y(n, e) {
    var t, r, i;
    if (n === e) return !0;
    if (n && e && (t = n.constructor) === e.constructor) {
        if (t === Date) return n.getTime() === e.getTime();
        if (t === RegExp) return n.toString() === e.toString();
        if (t === Array) {
            if ((r = n.length) === e.length) for(; r-- && Y(n[r], e[r]););
            return r === -1;
        }
        if (t === Set) {
            if (n.size !== e.size) return !1;
            for (r of n)if (i = r, i && typeof i == "object" && (i = St(e, i), !i) || !e.has(i)) return !1;
            return !0;
        }
        if (t === Map) {
            if (n.size !== e.size) return !1;
            for (r of n)if (i = r[0], i && typeof i == "object" && (i = St(e, i), !i) || !Y(r[1], e.get(i))) return !1;
            return !0;
        }
        if (t === ArrayBuffer) n = new Uint8Array(n), e = new Uint8Array(e);
        else if (t === DataView) {
            if ((r = n.byteLength) === e.byteLength) for(; r-- && n.getInt8(r) === e.getInt8(r););
            return r === -1;
        }
        if (ArrayBuffer.isView(n)) {
            if ((r = n.byteLength) === e.byteLength) for(; r-- && n[r] === e[r];);
            return r === -1;
        }
        if (!t || typeof n == "object") {
            r = 0;
            for(t in n)if (wt.call(n, t) && ++r && !wt.call(e, t) || !(t in e) || !Y(n[t], e[t])) return !1;
            return Object.keys(e).length === r;
        }
    }
    return n !== n && e !== e;
}
var P = /* @__PURE__ */ ((n)=>(n.Created = "message.created", n.Updated = "message.updated", n.Deleted = "message.deleted", n))(P || {}), Ct = /* @__PURE__ */ ((n)=>(n.ChatMessage = "chat.message", n))(Ct || {}), Ot = /* @__PURE__ */ ((n)=>(n.Occupancy = "[meta]occupancy", n))(Ot || {}), R = /* @__PURE__ */ ((n)=>(n.MessageCreate = "message.create", n.MessageUpdate = "message.update", n.MessageDelete = "message.delete", n.MessageAnnotationSummary = "message.summary", n.MessageMetaOccupancy = "meta.occupancy", n))(R || {}), dr = /* @__PURE__ */ ((n)=>(n.Enter = "enter", n.Leave = "leave", n.Update = "update", n.Present = "present", n))(dr || {}), T = /* @__PURE__ */ ((n)=>(n.Started = "typing.started", n.Stopped = "typing.stopped", n))(T || {}), k = /* @__PURE__ */ ((n)=>(n.SetChanged = "typing.set.changed", n))(k || {}), Ee = /* @__PURE__ */ ((n)=>(n.Reaction = "roomReaction", n))(Ee || {}), Ce = /* @__PURE__ */ ((n)=>(n.Reaction = "reaction", n))(Ce || {}), z = /* @__PURE__ */ ((n)=>(n.Unique = "unique", n.Distinct = "distinct", n.Multiple = "multiple", n))(z || {}), he = /* @__PURE__ */ ((n)=>(n.Unique = "reaction:unique.v1", n.Distinct = "reaction:distinct.v1", n.Multiple = "reaction:multiple.v1", n))(he || {});
const _r = {
    "reaction:unique.v1": "unique",
    "reaction:distinct.v1": "distinct",
    "reaction:multiple.v1": "multiple"
};
var M = /* @__PURE__ */ ((n)=>(n.Create = "reaction.create", n.Delete = "reaction.delete", n.Summary = "reaction.summary", n))(M || {}), Oe = /* @__PURE__ */ ((n)=>(n.Updated = "occupancy.updated", n))(Oe || {}), J = /* @__PURE__ */ ((n)=>(n.Discontinuity = "room.discontinuity", n))(J || {}), ce = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : ("TURBOPACK compile-time value", "object") < "u" ? /*TURBOPACK member replacement*/ __turbopack_context__.g : typeof self < "u" ? self : {};
function pr(n) {
    return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
}
var X = {
    exports: {}
};
X.exports;
var vt;
function fr() {
    return vt || (vt = 1, function(n, e) {
        var t = 200, r = "__lodash_hash_undefined__", i = 9007199254740991, c = "[object Arguments]", l = "[object Array]", d = "[object Boolean]", g = "[object Date]", m = "[object Error]", _ = "[object Function]", S = "[object GeneratorFunction]", Z = "[object Map]", Le = "[object Number]", _e = "[object Object]", Pe = "[object Promise]", Ne = "[object RegExp]", ee = "[object Set]", Ue = "[object String]", qe = "[object Symbol]", pe = "[object WeakMap]", je = "[object ArrayBuffer]", te = "[object DataView]", ke = "[object Float32Array]", ze = "[object Float64Array]", Be = "[object Int8Array]", Fe = "[object Int16Array]", $e = "[object Int32Array]", He = "[object Uint8Array]", Ve = "[object Uint8ClampedArray]", Ge = "[object Uint16Array]", We = "[object Uint32Array]", Nt = /[\\^$.*+?()[\]{}|]/g, Ut = /\w*$/, qt = /^\[object .+?Constructor\]$/, jt = /^(?:0|[1-9]\d*)$/, p = {};
        p[c] = p[l] = p[je] = p[te] = p[d] = p[g] = p[ke] = p[ze] = p[Be] = p[Fe] = p[$e] = p[Z] = p[Le] = p[_e] = p[Ne] = p[ee] = p[Ue] = p[qe] = p[He] = p[Ve] = p[Ge] = p[We] = !0, p[m] = p[_] = p[pe] = !1;
        var kt = typeof ce == "object" && ce && ce.Object === Object && ce, zt = typeof self == "object" && self && self.Object === Object && self, E = kt || zt || Function("return this")(), Ke = e && !e.nodeType && e, Qe = Ke && !0 && n && !n.nodeType && n, Bt = Qe && Qe.exports === Ke;
        function Ft(s, a) {
            return s.set(a[0], a[1]), s;
        }
        function $t(s, a) {
            return s.add(a), s;
        }
        function Ht(s, a) {
            for(var o = -1, h = s ? s.length : 0; ++o < h && a(s[o], o, s) !== !1;);
            return s;
        }
        function Vt(s, a) {
            for(var o = -1, h = a.length, y = s.length; ++o < h;)s[y + o] = a[o];
            return s;
        }
        function Je(s, a, o, h) {
            for(var y = -1, b = s ? s.length : 0; ++y < b;)o = a(o, s[y], y, s);
            return o;
        }
        function Gt(s, a) {
            for(var o = -1, h = Array(s); ++o < s;)h[o] = a(o);
            return h;
        }
        function Wt(s, a) {
            return s?.[a];
        }
        function Xe(s) {
            var a = !1;
            if (s != null && typeof s.toString != "function") try {
                a = !!(s + "");
            } catch  {}
            return a;
        }
        function Ye(s) {
            var a = -1, o = Array(s.size);
            return s.forEach(function(h, y) {
                o[++a] = [
                    y,
                    h
                ];
            }), o;
        }
        function fe(s, a) {
            return function(o) {
                return s(a(o));
            };
        }
        function Ze(s) {
            var a = -1, o = Array(s.size);
            return s.forEach(function(h) {
                o[++a] = h;
            }), o;
        }
        var Kt = Array.prototype, Qt = Function.prototype, se = Object.prototype, me = E["__core-js_shared__"], et = function() {
            var s = /[^.]+$/.exec(me && me.keys && me.keys.IE_PROTO || "");
            return s ? "Symbol(src)_1." + s : "";
        }(), tt = Qt.toString, I = se.hasOwnProperty, re = se.toString, Jt = RegExp("^" + tt.call(I).replace(Nt, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), st = Bt ? E.Buffer : void 0, rt = E.Symbol, nt = E.Uint8Array, Xt = fe(Object.getPrototypeOf, Object), Yt = Object.create, Zt = se.propertyIsEnumerable, es = Kt.splice, it = Object.getOwnPropertySymbols, ts = st ? st.isBuffer : void 0, ss = fe(Object.keys, Object), ye = V(E, "DataView"), K = V(E, "Map"), be = V(E, "Promise"), we = V(E, "Set"), Se = V(E, "WeakMap"), Q = V(Object, "create"), rs = j(ye), ns = j(K), is = j(be), as = j(we), os = j(Se), at = rt ? rt.prototype : void 0, ot = at ? at.valueOf : void 0;
        function U(s) {
            var a = -1, o = s ? s.length : 0;
            for(this.clear(); ++a < o;){
                var h = s[a];
                this.set(h[0], h[1]);
            }
        }
        function cs() {
            this.__data__ = Q ? Q(null) : {};
        }
        function hs(s) {
            return this.has(s) && delete this.__data__[s];
        }
        function ls(s) {
            var a = this.__data__;
            if (Q) {
                var o = a[s];
                return o === r ? void 0 : o;
            }
            return I.call(a, s) ? a[s] : void 0;
        }
        function us(s) {
            var a = this.__data__;
            return Q ? a[s] !== void 0 : I.call(a, s);
        }
        function gs(s, a) {
            var o = this.__data__;
            return o[s] = Q && a === void 0 ? r : a, this;
        }
        U.prototype.clear = cs, U.prototype.delete = hs, U.prototype.get = ls, U.prototype.has = us, U.prototype.set = gs;
        function C(s) {
            var a = -1, o = s ? s.length : 0;
            for(this.clear(); ++a < o;){
                var h = s[a];
                this.set(h[0], h[1]);
            }
        }
        function ds() {
            this.__data__ = [];
        }
        function _s(s) {
            var a = this.__data__, o = ne(a, s);
            if (o < 0) return !1;
            var h = a.length - 1;
            return o == h ? a.pop() : es.call(a, o, 1), !0;
        }
        function ps(s) {
            var a = this.__data__, o = ne(a, s);
            return o < 0 ? void 0 : a[o][1];
        }
        function fs(s) {
            return ne(this.__data__, s) > -1;
        }
        function ms(s, a) {
            var o = this.__data__, h = ne(o, s);
            return h < 0 ? o.push([
                s,
                a
            ]) : o[h][1] = a, this;
        }
        C.prototype.clear = ds, C.prototype.delete = _s, C.prototype.get = ps, C.prototype.has = fs, C.prototype.set = ms;
        function $(s) {
            var a = -1, o = s ? s.length : 0;
            for(this.clear(); ++a < o;){
                var h = s[a];
                this.set(h[0], h[1]);
            }
        }
        function ys() {
            this.__data__ = {
                hash: new U(),
                map: new (K || C)(),
                string: new U()
            };
        }
        function bs(s) {
            return ie(this, s).delete(s);
        }
        function ws(s) {
            return ie(this, s).get(s);
        }
        function Ss(s) {
            return ie(this, s).has(s);
        }
        function vs(s, a) {
            return ie(this, s).set(s, a), this;
        }
        $.prototype.clear = ys, $.prototype.delete = bs, $.prototype.get = ws, $.prototype.has = Ss, $.prototype.set = vs;
        function H(s) {
            this.__data__ = new C(s);
        }
        function Rs() {
            this.__data__ = new C();
        }
        function Ts(s) {
            return this.__data__.delete(s);
        }
        function Ms(s) {
            return this.__data__.get(s);
        }
        function As(s) {
            return this.__data__.has(s);
        }
        function Es(s, a) {
            var o = this.__data__;
            if (o instanceof C) {
                var h = o.__data__;
                if (!K || h.length < t - 1) return h.push([
                    s,
                    a
                ]), this;
                o = this.__data__ = new $(h);
            }
            return o.set(s, a), this;
        }
        H.prototype.clear = Rs, H.prototype.delete = Ts, H.prototype.get = Ms, H.prototype.has = As, H.prototype.set = Es;
        function Cs(s, a) {
            var o = Te(s) || Ys(s) ? Gt(s.length, String) : [], h = o.length, y = !!h;
            for(var b in s)I.call(s, b) && !(y && (b == "length" || Ks(b, h))) && o.push(b);
            return o;
        }
        function ct(s, a, o) {
            var h = s[a];
            (!(I.call(s, a) && gt(h, o)) || o === void 0 && !(a in s)) && (s[a] = o);
        }
        function ne(s, a) {
            for(var o = s.length; o--;)if (gt(s[o][0], a)) return o;
            return -1;
        }
        function Os(s, a) {
            return s && ht(a, Me(a), s);
        }
        function ve(s, a, o, h, y, b, O) {
            var w;
            if (h && (w = b ? h(s, y, b, O) : h(s)), w !== void 0) return w;
            if (!ae(s)) return s;
            var pt = Te(s);
            if (pt) {
                if (w = Vs(s), !a) return Fs(s, w);
            } else {
                var G = q(s), ft = G == _ || G == S;
                if (er(s)) return Ns(s, a);
                if (G == _e || G == c || ft && !b) {
                    if (Xe(s)) return b ? s : {};
                    if (w = Gs(ft ? {} : s), !a) return $s(s, Os(w, s));
                } else {
                    if (!p[G]) return b ? s : {};
                    w = Ws(s, G, ve, a);
                }
            }
            O || (O = new H());
            var mt = O.get(s);
            if (mt) return mt;
            if (O.set(s, w), !pt) var yt = o ? Hs(s) : Me(s);
            return Ht(yt || s, function(Ae, oe) {
                yt && (oe = Ae, Ae = s[oe]), ct(w, oe, ve(Ae, a, o, h, oe, s, O));
            }), w;
        }
        function Is(s) {
            return ae(s) ? Yt(s) : {};
        }
        function Ds(s, a, o) {
            var h = a(s);
            return Te(s) ? h : Vt(h, o(s));
        }
        function xs(s) {
            return re.call(s);
        }
        function Ls(s) {
            if (!ae(s) || Js(s)) return !1;
            var a = _t(s) || Xe(s) ? Jt : qt;
            return a.test(j(s));
        }
        function Ps(s) {
            if (!ut(s)) return ss(s);
            var a = [];
            for(var o in Object(s))I.call(s, o) && o != "constructor" && a.push(o);
            return a;
        }
        function Ns(s, a) {
            if (a) return s.slice();
            var o = new s.constructor(s.length);
            return s.copy(o), o;
        }
        function Re(s) {
            var a = new s.constructor(s.byteLength);
            return new nt(a).set(new nt(s)), a;
        }
        function Us(s, a) {
            var o = a ? Re(s.buffer) : s.buffer;
            return new s.constructor(o, s.byteOffset, s.byteLength);
        }
        function qs(s, a, o) {
            var h = a ? o(Ye(s), !0) : Ye(s);
            return Je(h, Ft, new s.constructor());
        }
        function js(s) {
            var a = new s.constructor(s.source, Ut.exec(s));
            return a.lastIndex = s.lastIndex, a;
        }
        function ks(s, a, o) {
            var h = a ? o(Ze(s), !0) : Ze(s);
            return Je(h, $t, new s.constructor());
        }
        function zs(s) {
            return ot ? Object(ot.call(s)) : {};
        }
        function Bs(s, a) {
            var o = a ? Re(s.buffer) : s.buffer;
            return new s.constructor(o, s.byteOffset, s.length);
        }
        function Fs(s, a) {
            var o = -1, h = s.length;
            for(a || (a = Array(h)); ++o < h;)a[o] = s[o];
            return a;
        }
        function ht(s, a, o, h) {
            o || (o = {});
            for(var y = -1, b = a.length; ++y < b;){
                var O = a[y], w = void 0;
                ct(o, O, ("TURBOPACK compile-time truthy", 1) ? s[O] : "TURBOPACK unreachable");
            }
            return o;
        }
        function $s(s, a) {
            return ht(s, lt(s), a);
        }
        function Hs(s) {
            return Ds(s, Me, lt);
        }
        function ie(s, a) {
            var o = s.__data__;
            return Qs(a) ? o[typeof a == "string" ? "string" : "hash"] : o.map;
        }
        function V(s, a) {
            var o = Wt(s, a);
            return Ls(o) ? o : void 0;
        }
        var lt = it ? fe(it, Object) : rr, q = xs;
        (ye && q(new ye(new ArrayBuffer(1))) != te || K && q(new K()) != Z || be && q(be.resolve()) != Pe || we && q(new we()) != ee || Se && q(new Se()) != pe) && (q = function(s) {
            var a = re.call(s), o = a == _e ? s.constructor : void 0, h = o ? j(o) : void 0;
            if (h) switch(h){
                case rs:
                    return te;
                case ns:
                    return Z;
                case is:
                    return Pe;
                case as:
                    return ee;
                case os:
                    return pe;
            }
            return a;
        });
        function Vs(s) {
            var a = s.length, o = s.constructor(a);
            return a && typeof s[0] == "string" && I.call(s, "index") && (o.index = s.index, o.input = s.input), o;
        }
        function Gs(s) {
            return typeof s.constructor == "function" && !ut(s) ? Is(Xt(s)) : {};
        }
        function Ws(s, a, o, h) {
            var y = s.constructor;
            switch(a){
                case je:
                    return Re(s);
                case d:
                case g:
                    return new y(+s);
                case te:
                    return Us(s, h);
                case ke:
                case ze:
                case Be:
                case Fe:
                case $e:
                case He:
                case Ve:
                case Ge:
                case We:
                    return Bs(s, h);
                case Z:
                    return qs(s, h, o);
                case Le:
                case Ue:
                    return new y(s);
                case Ne:
                    return js(s);
                case ee:
                    return ks(s, h, o);
                case qe:
                    return zs(s);
            }
        }
        function Ks(s, a) {
            return a = a ?? i, !!a && (typeof s == "number" || jt.test(s)) && s > -1 && s % 1 == 0 && s < a;
        }
        function Qs(s) {
            var a = typeof s;
            return a == "string" || a == "number" || a == "symbol" || a == "boolean" ? s !== "__proto__" : s === null;
        }
        function Js(s) {
            return !!et && et in s;
        }
        function ut(s) {
            var a = s && s.constructor, o = typeof a == "function" && a.prototype || se;
            return s === o;
        }
        function j(s) {
            if (s != null) {
                try {
                    return tt.call(s);
                } catch  {}
                try {
                    return s + "";
                } catch  {}
            }
            return "";
        }
        function Xs(s) {
            return ve(s, !0, !0);
        }
        function gt(s, a) {
            return s === a || s !== s && a !== a;
        }
        function Ys(s) {
            return Zs(s) && I.call(s, "callee") && (!Zt.call(s, "callee") || re.call(s) == c);
        }
        var Te = Array.isArray;
        function dt(s) {
            return s != null && tr(s.length) && !_t(s);
        }
        function Zs(s) {
            return sr(s) && dt(s);
        }
        var er = ts || nr;
        function _t(s) {
            var a = ae(s) ? re.call(s) : "";
            return a == _ || a == S;
        }
        function tr(s) {
            return typeof s == "number" && s > -1 && s % 1 == 0 && s <= i;
        }
        function ae(s) {
            var a = typeof s;
            return !!s && (a == "object" || a == "function");
        }
        function sr(s) {
            return !!s && typeof s == "object";
        }
        function Me(s) {
            return dt(s) ? Cs(s) : Ps(s);
        }
        function rr() {
            return [];
        }
        function nr() {
            return !1;
        }
        n.exports = Xs;
    }(X, X.exports)), X.exports;
}
var mr = fr();
const D = /* @__PURE__ */ pr(mr);
class x {
    constructor({ serial: e, clientId: t, text: r, metadata: i, headers: c, action: l, version: d, timestamp: g, reactions: m }){
        this.serial = e, this.clientId = t, this.text = r, this.metadata = i, this.headers = c, this.action = l, this.version = d, this.timestamp = g, this.reactions = m, Object.freeze(this.version), Object.freeze(this.reactions), Object.freeze(this.reactions.multiple), Object.freeze(this.reactions.distinct), Object.freeze(this.reactions.unique), Object.freeze(this);
    }
    get isUpdated() {
        return this.action === R.MessageUpdate;
    }
    get isDeleted() {
        return this.action === R.MessageDelete;
    }
    get updatedBy() {
        return this.isUpdated ? this.version.clientId : void 0;
    }
    get deletedBy() {
        return this.isDeleted ? this.version.clientId : void 0;
    }
    get updatedAt() {
        return this.isUpdated ? this.version.timestamp : void 0;
    }
    get deletedAt() {
        return this.isDeleted ? this.version.timestamp : void 0;
    }
    isOlderVersionOf(e) {
        return this._compareVersions(this, e, (t, r)=>t.serial < r.serial);
    }
    isNewerVersionOf(e) {
        return this._compareVersions(this, e, (t, r)=>t.serial > r.serial);
    }
    isSameVersionAs(e) {
        return this._compareVersions(this, e, (t, r)=>t.serial === r.serial);
    }
    _isNewerOrSameVersionOf(e) {
        return this._compareVersions(this, e, (t, r)=>t.serial >= r.serial);
    }
    before(e) {
        return this.serial < e.serial;
    }
    after(e) {
        return this.serial > e.serial;
    }
    equal(e) {
        return this.serial === e.serial;
    }
    isSameAs(e) {
        return this.equal(e);
    }
    with(e) {
        if ("serial" in e) return this._getLatestMessageVersion(e);
        if (e.type === P.Created) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ably$2f$build$2f$ably$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ErrorInfo"]("cannot apply a created event to a message", 4e4, 400);
        if (e.type === M.Summary) {
            if (e.summary.messageSerial !== this.serial) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ably$2f$build$2f$ably$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ErrorInfo"]("cannot apply event for a different message", 4e4, 400);
            const t = {
                unique: D(e.summary.unique),
                distinct: D(e.summary.distinct),
                multiple: D(e.summary.multiple)
            };
            return x._clone(this, {
                reactions: t
            });
        }
        return this._getLatestMessageVersion(e.message);
    }
    _compareVersions(e, t, r) {
        return e.equal(t) ? e.equal(t) && r(e.version, t.version) : !1;
    }
    /**
   * Get the latest message version, based on the event.
   * If "this" is the latest version, return "this", otherwise clone the message and apply the reactions.
   * @param message The message to get the latest version of
   * @returns The latest message version
   */ _getLatestMessageVersion(e) {
        if (e.serial !== this.serial) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ably$2f$build$2f$ably$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ErrorInfo"]("cannot apply event for a different message", 4e4, 400);
        return this._isNewerOrSameVersionOf(e) ? this : x._clone(e, {
            reactions: this.reactions
        });
    }
    // Clone a message, optionally replace the given fields
    static _clone(e, t) {
        return new x({
            serial: t?.serial ?? e.serial,
            clientId: t?.clientId ?? e.clientId,
            text: t?.text ?? e.text,
            metadata: t?.metadata ?? D(e.metadata),
            headers: t?.headers ?? D(e.headers),
            action: t?.action ?? e.action,
            version: t?.version ?? D(e.version),
            timestamp: t?.timestamp ?? e.timestamp,
            reactions: t?.reactions ?? D(e.reactions)
        });
    }
    copy(e = {}) {
        return x._clone(this, e);
    }
}
const xe = ()=>({
        unique: {},
        distinct: {},
        multiple: {}
    }), yr = (n)=>{
    const e = n, t = e.data && typeof e.data == "object" ? e.data : {}, r = e.extras && typeof e.extras == "object" ? e.extras : {}, i = e.clientId || "", c = t.text || "", l = new Date(e.timestamp || 0), d = e.serial || "", g = t.metadata && typeof t.metadata == "object" ? t.metadata : {}, m = r.headers || {}, _ = {
        ...e.version,
        // Spec: CHA-M4k6
        serial: e.version.serial || d,
        // Spec: CHA-M4k7
        timestamp: new Date(e.version.timestamp || l)
    }, S = Object.values(R).includes(e.action) ? e.action : R.MessageCreate;
    return new x({
        serial: d,
        clientId: i,
        text: c,
        metadata: g,
        headers: m,
        action: S,
        version: _,
        timestamp: l,
        reactions: xe()
    });
}, W = (n)=>{
    let e = "";
    if (typeof n == "string") e = n;
    else try {
        "serial" in n && (e = n.serial);
    } catch  {}
    if (e === "") throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ably$2f$build$2f$ably$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ErrorInfo"]("invalid serial; must be string or object with serial property", 4e4, 400);
    return e;
}, br = {
    "annotation.create": M.Create,
    "annotation.delete": M.Delete
};
class It {
    constructor(e, t, r, i, c){
        this._logger = e, this._options = t, this._api = r, this._roomName = i, this._channel = c, this._emitter = new A(), this._unsubscribeMessageEvents = F(c, this._processMessageEvent.bind(this)), this._options?.rawMessageReactions && (this._unsubscribeAnnotationEvents = F(c.annotations, this._processAnnotationEvent.bind(this))), this._defaultType = this._options?.defaultMessageReactionType ?? z.Distinct;
    }
    _processAnnotationEvent(e) {
        this._logger.trace("MessagesReactions._processAnnotationEvent();", {
            event: e
        });
        const t = _r[e.type];
        if (!t) {
            this._logger.info("MessagesReactions._processAnnotationEvent(); ignoring unknown reaction type", {
                event: e
            });
            return;
        }
        const r = br[e.action];
        if (!r) {
            this._logger.info("MessagesReactions._processAnnotationEvent(); ignoring unknown reaction event type", {
                event: e
            });
            return;
        }
        const i = e.name ?? "", c = {
            type: r,
            timestamp: new Date(e.timestamp),
            reaction: {
                messageSerial: e.messageSerial,
                type: t,
                name: i,
                clientId: e.clientId ?? ""
            }
        };
        e.count ? c.reaction.count = e.count : r === M.Create && t === z.Multiple && (c.reaction.count = 1), this._emitter.emit(r, c);
    }
    _processMessageEvent(e) {
        if (this._logger.trace("MessagesReactions._processMessageEvent();", {
            event: e
        }), e.action !== R.MessageAnnotationSummary.valueOf()) return;
        const t = e.serial, r = e.annotations.summary, i = r[he.Unique] ?? {}, c = r[he.Distinct] ?? {}, l = r[he.Multiple] ?? {};
        this._emitter.emit(M.Summary, {
            type: M.Summary,
            summary: {
                messageSerial: t,
                unique: i,
                distinct: c,
                multiple: l
            }
        });
    }
    /**
   * @inheritDoc
   */ send(e, t) {
        this._logger.trace("MessagesReactions.send();", {
            messageSerial: e,
            params: t
        });
        const r = W(e);
        let { type: i, count: c } = t;
        i || (i = this._defaultType), i === z.Multiple && !c && (c = 1);
        const l = {
            type: i,
            name: t.name
        };
        return c && (l.count = c), this._api.sendMessageReaction(this._roomName, r, l);
    }
    /**
   * @inheritDoc
   */ delete(e, t) {
        this._logger.trace("MessagesReactions.delete();", {
            messageSerial: e,
            params: t
        });
        const r = W(e);
        let i = t?.type;
        if (i || (i = this._defaultType), i !== z.Unique && !t?.name) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ably$2f$build$2f$ably$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ErrorInfo"](`cannot delete reaction of type ${i} without a name`, 40001, 400);
        const c = {
            type: i
        };
        return i !== z.Unique && (c.name = t?.name), this._api.deleteMessageReaction(this._roomName, r, c);
    }
    /**
   * @inheritDoc
   */ subscribe(e) {
        this._logger.trace("MessagesReactions.subscribe();");
        const t = v(e);
        return this._emitter.on(M.Summary, t), {
            unsubscribe: ()=>{
                this._emitter.off(t);
            }
        };
    }
    /**
   * @inheritDoc
   */ subscribeRaw(e) {
        if (this._logger.trace("MessagesReactions.subscribeRaw();"), !this._options?.rawMessageReactions) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ably$2f$build$2f$ably$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ErrorInfo"]("Raw message reactions are not enabled", 40001, 400);
        const t = v(e);
        return this._emitter.on([
            M.Create,
            M.Delete
        ], t), {
            unsubscribe: ()=>{
                this._emitter.off(t);
            }
        };
    }
    /**
   * Merges the channel options to add support for message reactions.
   * @param roomOptions The room options to merge for.
   * @returns A function that merges the channel options for the room with the ones required for presence.
   */ static channelOptionMerger(e) {
        return (t)=>(t.modes.includes("ANNOTATION_PUBLISH") || t.modes.push("ANNOTATION_PUBLISH"), e.messages.rawMessageReactions && !t.modes.includes("ANNOTATION_SUBSCRIBE") && t.modes.push("ANNOTATION_SUBSCRIBE"), t);
    }
    clientReactions(e, t) {
        this._logger.trace("MessagesReactions.clientReactions();", {
            messageSerial: e,
            clientId: t
        });
        const r = W(e);
        return this._api.getClientReactions(this._roomName, r, t);
    }
    /**
   * Disposes of the message reactions instance, removing all listeners and subscriptions.
   * This method should be called when the room is being released to ensure proper cleanup.
   * @internal
   */ dispose() {
        this._logger.trace("DefaultMessageReactions.dispose();"), this._emitter.off(), this._unsubscribeMessageEvents(), this._unsubscribeAnnotationEvents?.(), this._logger.debug("DefaultMessageReactions.dispose(); disposed successfully");
    }
    /**
   * Checks if there are any listeners registered by users.
   * @internal
   * @returns true if there are listeners, false otherwise.
   */ hasListeners() {
        return N(this._emitter);
    }
}
const ue = (n)=>{
    const e = {
        ...xe(),
        ...n.reactions
    }, t = Object.values(R).includes(n.action) ? n.action : R.MessageCreate, r = {
        serial: n.version.serial,
        timestamp: new Date(n.version.timestamp),
        clientId: n.version.clientId,
        description: n.version.description,
        metadata: n.version.metadata
    };
    return new x({
        serial: n.serial,
        clientId: n.clientId,
        text: n.text,
        metadata: n.metadata,
        headers: n.headers,
        action: t,
        version: r,
        timestamp: new Date(n.timestamp),
        reactions: e
    });
}, wr = /* @__PURE__ */ new Map([
    [
        R.MessageCreate,
        P.Created
    ],
    [
        R.MessageUpdate,
        P.Updated
    ],
    [
        R.MessageDelete,
        P.Deleted
    ]
]);
var Ie = /* @__PURE__ */ ((n)=>(n.OldestFirst = "oldestFirst", n.NewestFirst = "newestFirst", n))(Ie || {});
class Sr {
    /**
   * Constructs a new `DefaultMessages` instance.
   * @param roomName The unique identifier of the room.
   * @param options The room options for the messages.
   * @param channel An instance of the Realtime channel for the room.
   * @param chatApi An instance of the ChatApi.
   * @param clientId The client ID of the user.
   * @param logger An instance of the Logger.
   */ constructor(e, t, r, i, c, l){
        this._pendingPromiseRejecters = /* @__PURE__ */ new Set(), this._pendingAttachListeners = /* @__PURE__ */ new Set(), this._emitter = new A(), this._roomName = e, this._options = t, this._channel = r, this._chatApi = i, this._clientId = c, this._logger = l, this._listenerSubscriptionPoints = /* @__PURE__ */ new Map(), this._reactions = new It(this._logger, t, this._chatApi, this._roomName, this._channel);
        const d = this._processEvent.bind(this), g = (_)=>{
            this._handleAttach(_.resumed);
        }, m = (_)=>{
            _.current === "attached" && _.previous === "attached" && this._handleAttach(_.resumed);
        };
        this._unsubscribeMessageEvents = F(this._channel, [
            Ct.ChatMessage
        ], d), this._offChannelAttached = L(this._channel, "attached", g), this._offChannelUpdate = L(this._channel, "update", m);
    }
    /**
   * @inheritdoc
   */ get reactions() {
        return this._reactions;
    }
    /**
   * @inheritdoc
   */ async _getBeforeSubscriptionStart(e, t) {
        this._logger.trace("DefaultSubscriptionManager.getBeforeSubscriptionStart();");
        const r = this._listenerSubscriptionPoints.get(e);
        if (r === void 0) throw this._logger.error("DefaultSubscriptionManager.getBeforeSubscriptionStart(); listener has not been subscribed yet"), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ably$2f$build$2f$ably$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ErrorInfo"]("cannot query history; listener has not been subscribed yet", 4e4, 400);
        const i = await r;
        return this._chatApi.history(this._roomName, {
            ...t,
            orderBy: "newestFirst",
            ...i
        });
    }
    /**
   * Handle the case where the channel experiences a detach and reattaches.
   * @param fromResume Whether the attach is from a resume operation.
   */ _handleAttach(e) {
        if (this._logger.trace("DefaultSubscriptionManager.handleAttach();"), e) return;
        const t = this._subscribeAtChannelAttach();
        for (const [r] of this._listenerSubscriptionPoints.entries())this._listenerSubscriptionPoints.set(r, t);
    }
    /**
   * Create a promise that resolves with the attachSerial of the channel or the serial of the latest message.
   * @returns A promise that resolves to an object containing fromSerial and subscriptionPoint.
   */ async _resolveSubscriptionStart() {
        const e = this._getChannelProperties();
        if (e.state === "attached") {
            if (e.properties.channelSerial) return {
                fromSerial: e.properties.channelSerial
            };
            throw this._logger.error("DefaultSubscriptionManager.handleAttach(); channelSerial is undefined"), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ably$2f$build$2f$ably$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ErrorInfo"]("channel is attached, but channelSerial is not defined", 4e4, 400);
        }
        return this._subscribeAtChannelAttach();
    }
    _getChannelProperties() {
        return this._channel;
    }
    async _subscribeAtChannelAttach() {
        const e = this._getChannelProperties();
        return new Promise((t, r)=>{
            this._pendingPromiseRejecters.add(r);
            const i = ()=>{
                this._pendingPromiseRejecters.delete(r);
            };
            if (e.state === "attached") {
                this._logger.debug("Messages._subscribeAtChannelAttach(); channel is attached already, using attachSerial", {
                    attachSerial: e.properties.attachSerial
                }), i(), e.properties.attachSerial ? t({
                    fromSerial: e.properties.attachSerial
                }) : (this._logger.error("DefaultSubscriptionManager.handleAttach(); attachSerial is undefined"), i(), r(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ably$2f$build$2f$ably$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ErrorInfo"]("channel is attached, but attachSerial is not defined", 4e4, 400)));
                return;
            }
            const c = hr(e, "attached", ()=>{
                this._logger.debug("Messages._subscribeAtChannelAttach(); channel is now attached, using attachSerial", {
                    attachSerial: e.properties.attachSerial
                }), i(), this._pendingAttachListeners.delete(c), e.properties.attachSerial ? t({
                    fromSerial: e.properties.attachSerial
                }) : (this._logger.error("DefaultSubscriptionManager.handleAttach(); attachSerial is undefined"), r(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ably$2f$build$2f$ably$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ErrorInfo"]("channel is attached, but attachSerial is not defined", 4e4, 400)));
            });
            this._pendingAttachListeners.add(c);
        });
    }
    /**
   * @inheritdoc
   */ async history(e) {
        return this._logger.trace("Messages.query();"), this._chatApi.history(this._roomName, e);
    }
    /**
   * @inheritdoc
   */ get(e) {
        return this._logger.trace("Messages.get();", {
            serial: e
        }), this._chatApi.getMessage(this._roomName, W(e));
    }
    /**
   * @inheritdoc
   */ async send(e) {
        this._logger.trace("Messages.send();", {
            params: e
        });
        const { text: t, metadata: r, headers: i } = e, c = await this._chatApi.sendMessage(this._roomName, {
            text: t,
            headers: i,
            metadata: r
        }), l = new Date(c.timestamp);
        return new x({
            serial: c.serial,
            clientId: this._clientId,
            text: t,
            metadata: r ?? {},
            headers: i ?? {},
            action: R.MessageCreate,
            version: {
                serial: c.serial,
                timestamp: l
            },
            timestamp: l,
            reactions: xe()
        });
    }
    /**
   * @inheritdoc
   */ async delete(e, t) {
        this._logger.trace("Messages.delete();", {
            params: t
        }), e = W(e), this._logger.debug("Messages.delete(); serial", {
            serial: e
        });
        const r = await this._chatApi.deleteMessage(this._roomName, e, t);
        return ue(r);
    }
    /**
   * @inheritdoc
   */ async update(e, t, r) {
        this._logger.trace("Messages.update();", {
            updateParams: t,
            details: r
        }), e = W(e), this._logger.debug("Messages.update(); serial", {
            serial: e
        });
        const i = await this._chatApi.updateMessage(this._roomName, e, {
            message: {
                text: t.text,
                metadata: t.metadata,
                headers: t.headers
            },
            ...r
        });
        return this._logger.debug("Messages.update(); message update successfully", {
            updateParams: t
        }), ue(i);
    }
    /**
   * @inheritdoc
   */ subscribe(e) {
        this._logger.trace("Messages.subscribe();");
        const t = v(e);
        this._emitter.on([
            P.Created,
            P.Updated,
            P.Deleted
        ], t);
        const r = this._resolveSubscriptionStart();
        return r.catch(()=>{
            this._logger.debug("Messages.subscribe(); subscription point was not resolved before the room was released");
        }), this._listenerSubscriptionPoints.set(t, r), {
            unsubscribe: ()=>{
                this._listenerSubscriptionPoints.delete(t), this._logger.trace("Messages.unsubscribe();"), this._emitter.off(t);
            },
            historyBeforeSubscribe: (i)=>this._getBeforeSubscriptionStart(t, i)
        };
    }
    _processEvent(e) {
        this._logger.trace("Messages._processEvent();", {
            channelEventMessage: e
        });
        const { action: t } = e, r = wr.get(t);
        if (!r) {
            this._logger.debug("Messages._processEvent(); received unknown message action", {
                action: t
            });
            return;
        }
        const i = yr(e);
        this._emitter.emit(r, {
            type: r,
            message: i
        });
    }
    /**
   * Disposes of the messages instance, removing all listeners and subscriptions.
   * This method should be called when the room is being released to ensure proper cleanup.
   * @internal
   */ dispose() {
        this._logger.trace("DefaultMessages.dispose();"), this._emitter.off();
        const e = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ably$2f$build$2f$ably$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ErrorInfo"]("room has been disposed", 4e4, 400);
        for (const t of this._pendingPromiseRejecters)try {
            t(e);
        } catch  {}
        this._pendingPromiseRejecters.clear(), this._listenerSubscriptionPoints.clear();
        for (const t of this._pendingAttachListeners)t();
        this._pendingAttachListeners.clear(), this._unsubscribeMessageEvents(), this._offChannelAttached(), this._offChannelUpdate(), this._reactions.dispose(), this._logger.debug("DefaultMessages.dispose(); disposed successfully");
    }
    /**
   * Checks if there are any listeners registered by users.
   * @internal
   * @returns true if there are listeners, false otherwise.
   */ hasListeners() {
        return N(this._emitter);
    }
}
class vr {
    constructor(e, t){
        this._apiProtocolVersion = 4, this._realtime = e, this._logger = t;
    }
    async history(e, t) {
        const r = {
            ...t
        };
        if (t.orderBy) switch(t.orderBy){
            case Ie.NewestFirst:
                {
                    r.direction = "backwards";
                    break;
                }
            case Ie.OldestFirst:
                {
                    r.direction = "forwards";
                    break;
                }
            default:
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ably$2f$build$2f$ably$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ErrorInfo"](`invalid orderBy value: ${t.orderBy}`, 4e4, 400);
        }
        const i = await this._makeAuthorizedPaginatedRequest(this._roomUrl(e, "/messages"), r);
        return this._recursivePaginateMessages(i);
    }
    _recursivePaginateMessages(e) {
        const t = {};
        return t.items = e.items.map((r)=>ue(r)), t.next = ()=>e.next().then((r)=>r ? this._recursivePaginateMessages(r) : null), t.first = ()=>e.first().then((r)=>this._recursivePaginateMessages(r)), t.current = ()=>e.current().then((r)=>this._recursivePaginateMessages(r)), t.hasNext = ()=>e.hasNext(), t.isLast = ()=>e.isLast(), {
            ...e,
            ...t
        };
    }
    async getMessage(e, t) {
        const r = await this._makeAuthorizedRequest(this._messageUrl(e, t), "GET");
        return ue(r);
    }
    deleteMessage(e, t, r) {
        const i = {
            ...r?.description && {
                description: r.description
            },
            ...r?.metadata && {
                metadata: r.metadata
            }
        };
        return this._makeAuthorizedRequest(this._messageUrl(e, t, "/delete"), "POST", i, {});
    }
    sendMessage(e, t) {
        const r = {
            text: t.text,
            ...t.metadata && {
                metadata: t.metadata
            },
            ...t.headers && {
                headers: t.headers
            }
        };
        return this._makeAuthorizedRequest(this._roomUrl(e, "/messages"), "POST", r);
    }
    updateMessage(e, t, r) {
        return this._makeAuthorizedRequest(this._messageUrl(e, t), "PUT", r);
    }
    sendMessageReaction(e, t, r) {
        return this._makeAuthorizedRequest(this._messageUrl(e, t, "/reactions"), "POST", r);
    }
    deleteMessageReaction(e, t, r) {
        return this._makeAuthorizedRequest(this._messageUrl(e, t, "/reactions"), "DELETE", void 0, r);
    }
    getClientReactions(e, t, r) {
        const i = r ? {
            forClientId: r
        } : {};
        return this._makeAuthorizedRequest(this._messageUrl(e, t, "/client-reactions"), "GET", void 0, i);
    }
    getOccupancy(e) {
        return this._makeAuthorizedRequest(this._roomUrl(e, "/occupancy"), "GET");
    }
    async _makeAuthorizedRequest(e, t, r, i) {
        return (await this._doRequest(e, t, i, r)).items[0];
    }
    async _makeAuthorizedPaginatedRequest(e, t, r) {
        return this._doRequest(e, "GET", t, r);
    }
    async _doRequest(e, t, r, i) {
        const c = await this._realtime.request(t, e, this._apiProtocolVersion, r, i);
        if (!c.success) throw this._logger.error("ChatApi._doRequest(); failed to make request", {
            url: e,
            method: t,
            statusCode: c.statusCode,
            errorCode: c.errorCode,
            errorMessage: c.errorMessage
        }), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ably$2f$build$2f$ably$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ErrorInfo"](c.errorMessage, c.errorCode, c.statusCode);
        return c;
    }
    /**
   * Returns a URL for a specific room.
   * @param roomName Name of the room
   * @param suffix The suffix to add to the room URL, prefixed with /
   * @returns string The formatted URL
   */ _roomUrl(e, t = "") {
        return `/chat/v4/rooms/${encodeURIComponent(e)}${t}`;
    }
    /**
   * Returns a URL for a specific message in the room.
   * @param roomName string Name of the room
   * @param serial string The serial of the message
   * @param suffix The suffix to add to the room URL, prefixed with /
   * @returns string The formatted URL
   */ _messageUrl(e, t, r = "") {
        return `${this._roomUrl(e, "/messages")}/${encodeURIComponent(t)}${r}`;
    }
}
var B = /* @__PURE__ */ ((n)=>(n[n.BadRequest = 4e4] = "BadRequest", n[n.MessageRejectedByBeforePublishRule = 42211] = "MessageRejectedByBeforePublishRule", n[n.MessageRejectedByModeration = 42213] = "MessageRejectedByModeration", n[n.PresenceAutoReentryFailed = 91004] = "PresenceAutoReentryFailed", n[n.RoomDiscontinuity = 102100] = "RoomDiscontinuity", n[n.RoomInFailedState = 102101] = "RoomInFailedState", n[n.RoomIsReleasing = 102102] = "RoomIsReleasing", n[n.RoomIsReleased = 102103] = "RoomIsReleased", n[n.RoomReleasedBeforeOperationCompleted = 102106] = "RoomReleasedBeforeOperationCompleted", n))(B || {});
const Jr = (n, e)=>n.code === e, Rr = (n)=>`${n}::$chat`, ge = "0.14.1", Dt = `chat-js/${ge}`, Tr = `chat-react/${ge}`, xt = [
    "PUBLISH",
    "SUBSCRIBE"
], Mr = {
    params: {
        agent: Dt
    },
    attachOnSubscribe: !1,
    modes: xt
}, Ar = {
    // Spec: CHA-IN1b1
    params: {
        agent: `${Dt} ${Tr}`
    },
    attachOnSubscribe: !1,
    modes: xt
};
class Er {
    constructor(e, t, r, i){
        r.trace("ChannelManager();", {
            isReact: i
        }), this._realtime = t, this._logger = r, this._isReact = i, this._registeredOptions = this._defaultChannelOptions(), this._channelId = Rr(e);
    }
    mergeOptions(e) {
        if (this._logger.trace("ChannelManager.mergeOptions();"), this._resolvedChannel) throw this._logger.error("channel options cannot be modified after the channel has been requested"), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ably$2f$build$2f$ably$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ErrorInfo"]("channel options cannot be modified after the channel has been requested", 4e4, 400);
        this._registeredOptions = e(this._registeredOptions);
    }
    get() {
        return this._logger.trace("ChannelManager.get();"), this._resolvedChannel ??= this._realtime.channels.get(this._channelId, this._registeredOptions), this._resolvedChannel;
    }
    release() {
        this._logger.trace("ChannelManager.release();", {
            channelId: this._channelId
        }), this._resolvedChannel && this._realtime.channels.release(this._channelId);
    }
    _defaultChannelOptions() {
        this._logger.trace("ChannelManager._defaultChannelOptions();");
        const e = this._isReact ? Ar : Mr;
        return this._logger.trace(this._isReact ? "using react channel options" : "using default channel options"), {
            ...e,
            modes: [
                ...e.modes ?? []
            ]
        };
    }
}
const Cr = (n)=>{
    const e = n;
    let t = 0, r = 0;
    if (!e.data || typeof e.data != "object") return {
        connections: t,
        presenceMembers: r
    };
    const { metrics: i } = e.data;
    return !i || typeof i != "object" ? {
        connections: t,
        presenceMembers: r
    } : (typeof i.connections == "number" && Number.isInteger(i.connections) && (t = i.connections), typeof i.presenceMembers == "number" && Number.isInteger(i.presenceMembers) && (r = i.presenceMembers), {
        connections: t,
        presenceMembers: r
    });
};
class Rt {
    /**
   * Constructs a new `DefaultOccupancy` instance.
   * @param roomName The unique identifier of the room.
   * @param channel An instance of the Realtime channel.
   * @param chatApi An instance of the ChatApi.
   * @param logger An instance of the Logger.
   * @param roomOptions The room options.
   */ constructor(e, t, r, i, c){
        this._emitter = new A(), this._roomName = e, this._channel = t, this._chatApi = r, this._logger = i, this._roomOptions = c;
        const l = this._internalOccupancyListener.bind(this);
        this._roomOptions.occupancy.enableEvents ? (this._logger.debug("DefaultOccupancy(); subscribing to occupancy events"), this._unsubscribeOccupancyEvents = F(this._channel, [
            Ot.Occupancy
        ], l)) : this._unsubscribeOccupancyEvents = ()=>{};
    }
    /**
   * @inheritdoc
   */ subscribe(e) {
        if (this._logger.trace("Occupancy.subscribe();"), !this._roomOptions.occupancy.enableEvents) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ably$2f$build$2f$ably$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ErrorInfo"]("cannot subscribe to occupancy; occupancy events are not enabled in room options", 4e4, 400);
        const t = v(e);
        return this._emitter.on(t), {
            unsubscribe: ()=>{
                this._logger.trace("Occupancy.unsubscribe();"), this._emitter.off(t);
            }
        };
    }
    /**
   * @inheritdoc
   */ async get() {
        return this._logger.trace("Occupancy.get();"), this._chatApi.getOccupancy(this._roomName);
    }
    /**
   * @inheritdoc
   */ current() {
        if (this._logger.trace("Occupancy.current();"), !this._roomOptions.occupancy.enableEvents) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ably$2f$build$2f$ably$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ErrorInfo"]("cannot get current occupancy; occupancy events are not enabled in room options", 4e4, 400);
        return this._latestOccupancyData;
    }
    /**
   * An internal listener that listens for occupancy events from the underlying channel and translates them into
   * occupancy events for the public API.
   * @param message The inbound message containing occupancy data.
   */ _internalOccupancyListener(e) {
        this._logger.trace("Occupancy._internalOccupancyListener();", e), this._latestOccupancyData = Cr(e), this._emitter.emit(Oe.Updated, {
            type: Oe.Updated,
            occupancy: this._latestOccupancyData
        });
    }
    /**
   * Merges the channel options for the room with the ones required for occupancy.
   * @param roomOptions The internal room options.
   * @returns A function that merges the channel options for the room with the ones required for occupancy.
   */ static channelOptionMerger(e) {
        return (t)=>e.occupancy.enableEvents ? {
                ...t,
                params: {
                    ...t.params,
                    occupancy: "metrics"
                }
            } : t;
    }
    /**
   * Disposes of the occupancy instance, removing all listeners and subscriptions.
   * This method should be called when the room is being released to ensure proper cleanup.
   * @internal
   */ dispose() {
        this._logger.trace("DefaultOccupancy.dispose();"), this._unsubscribeOccupancyEvents(), this._emitter.off(), this._logger.debug("DefaultOccupancy.dispose(); disposed successfully");
    }
    /**
   * Checks if there are any listeners registered by users.
   * @internal
   * @returns true if there are listeners, false otherwise.
   */ hasListeners() {
        return N(this._emitter);
    }
}
class Tt {
    /**
   * Constructs a new `DefaultPresence` instance.
   * @param channel The Realtime channel instance.
   * @param clientId The client ID, attached to presences messages as an identifier of the sender.
   * A channel can have multiple connections using the same clientId.
   * @param logger An instance of the Logger.
   * @param options The room options.
   */ constructor(e, t, r, i){
        this._emitter = new A(), this._stateEmitter = new A(), this._presenceState = {
            present: !1
        }, this.subscribeToEvents = (g)=>{
            this._emitter.emit(g.action, {
                type: g.action,
                member: this._realtimeMemberToPresenceMember(g)
            });
        }, this._channel = e, this._clientId = t, this._logger = r, this._options = i;
        const c = this.subscribeToEvents.bind(this), l = (g)=>{
            if (g.reason?.code === 91004) {
                this._logger.debug("Presence auto-reentry failed", {
                    reason: g.reason
                }), this._emitPresenceStateChange(!1, g.reason);
                return;
            }
            if (g.current === "detached") {
                this._emitPresenceStateChange(!1);
                return;
            }
        }, d = (g)=>{
            this._emitPresenceStateChange(!1, g.reason);
        };
        this._offChannelUpdate = L(this._channel, "update", l), this._offChannelDetach = L(this._channel, [
            "detached",
            "failed"
        ], d), this._unsubscribePresenceEvents = F(this._channel.presence, c);
    }
    /**
   * @inheritDoc
   */ async get(e) {
        return this._logger.trace("Presence.get()", {
            params: e
        }), this._assertChannelState(), (await this._channel.presence.get(e)).map((r)=>this._realtimeMemberToPresenceMember(r));
    }
    /**
   * @inheritDoc
   */ async isUserPresent(e) {
        return this._logger.trace("Presence.isUserPresent()", {
            clientId: e
        }), this._assertChannelState(), (await this._channel.presence.get({
            clientId: e
        })).length > 0;
    }
    /**
   * @inheritDoc
   */ async enter(e) {
        this._logger.trace("Presence.enter()", {
            data: e
        }), this._assertChannelState();
        try {
            await this._channel.presence.enterClient(this._clientId, e), this._emitPresenceStateChange(!0);
        } catch (t) {
            throw this._emitPresenceStateChange(!1, t), t;
        }
    }
    /**
   * @inheritDoc
   */ async update(e) {
        this._logger.trace("Presence.update()", {
            data: e
        }), this._assertChannelState();
        try {
            await this._channel.presence.updateClient(this._clientId, e), this._emitPresenceStateChange(!0);
        } catch (t) {
            throw this._emitPresenceStateChange(!1, t), t;
        }
    }
    /**
   * @inheritDoc
   */ async leave(e) {
        this._logger.trace("Presence.leave()", {
            data: e
        }), this._assertChannelState();
        try {
            await this._channel.presence.leaveClient(this._clientId, e), this._emitPresenceStateChange(!1);
        } catch (t) {
            throw this._emitPresenceStateChange(!1, t), t;
        }
    }
    subscribe(e, t) {
        if (this._logger.trace("Presence.subscribe(); listenerOrEvents", {
            listenerOrEvents: e
        }), !this._options.presence.enableEvents) throw this._logger.error("could not subscribe to presence; presence events are not enabled"), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ably$2f$build$2f$ably$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ErrorInfo"]("could not subscribe to presence; presence events are not enabled", 4e4, 400);
        if (!e && !t) throw this._logger.error("could not subscribe to presence; invalid arguments"), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ably$2f$build$2f$ably$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ErrorInfo"]("could not subscribe listener: invalid arguments", 4e4, 400);
        if (t) {
            const r = v(t);
            return this._emitter.on(e, r), {
                unsubscribe: ()=>{
                    this._logger.trace("Presence.unsubscribe();", {
                        events: e
                    }), this._emitter.off(r);
                }
            };
        } else {
            const r = v(e);
            return this._emitter.on(r), {
                unsubscribe: ()=>{
                    this._logger.trace("Presence.unsubscribe();"), this._emitter.off(r);
                }
            };
        }
    }
    /**
   * Merges the channel options for the room with the ones required for presence.
   * @param roomOptions The room options to merge for.
   * @returns A function that merges the channel options for the room with the ones required for presence.
   */ static channelOptionMerger(e) {
        return (t)=>(t.modes.includes("PRESENCE") || t.modes.push("PRESENCE"), e.presence.enableEvents && !t.modes.includes("PRESENCE_SUBSCRIBE") && t.modes.push("PRESENCE_SUBSCRIBE"), t);
    }
    /**
   * Disposes of the presence instance, removing all listeners and subscriptions.
   * This method should be called when the room is being released to ensure proper cleanup.
   * @internal
   */ dispose() {
        this._logger.trace("DefaultPresence.dispose();"), this._emitter.off(), this._unsubscribePresenceEvents(), this._offChannelUpdate(), this._offChannelDetach(), this._logger.debug("DefaultPresence.dispose(); disposed successfully");
    }
    /**
   * Checks if there are any listeners registered by users.
   * @internal
   * @returns true if there are listeners, false otherwise.
   */ hasListeners() {
        return N(this._emitter);
    }
    /**
   * Converts an Ably presence message to a presence member.
   * @param member The Ably presence message to convert.
   * @returns The presence member.
   */ _realtimeMemberToPresenceMember(e) {
        return {
            ...e,
            data: e.data,
            updatedAt: new Date(e.timestamp)
        };
    }
    _assertChannelState() {
        if (this._channel.state !== "attaching" && this._channel.state !== "attached") throw this._logger.error("could not perform presence operation; room is not attached"), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ably$2f$build$2f$ably$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ErrorInfo"]("could not perform presence operation; room is not attached", 4e4, 400);
    }
    /**
   * Private method to emit the presence state change event.
   * @param present - Whether the user is present
   * @param error - Optional error information
   */ _emitPresenceStateChange(e, t) {
        this._logger.trace("Presence._emitPresenceStateChange()", {
            present: e,
            error: t
        });
        const r = {
            ...this._presenceState
        };
        this._presenceState = {
            present: e
        };
        const i = {
            previous: r,
            current: this._presenceState,
            error: t
        };
        this._stateEmitter.emit("presence.state.change", i);
    }
    /**
   * @param listener The listener to subscribe to presence state changes.
   * @returns A subscription that can be used to unsubscribe from presence state changes.
   * @internal
   */ onPresenceStateChange(e) {
        this._logger.trace("Presence.onPresenceStateChange()");
        const t = v(e);
        return this._stateEmitter.on("presence.state.change", t), {
            unsubscribe: ()=>{
                this._logger.trace("Presence.unsubscribeFromPresenceStateChanges()"), this._stateEmitter.off(t);
            }
        };
    }
}
const le = new Error("request for lock canceled");
var Or = function(n, e, t, r) {
    function i(c) {
        return c instanceof t ? c : new t(function(l) {
            l(c);
        });
    }
    return new (t || (t = Promise))(function(c, l) {
        function d(_) {
            try {
                m(r.next(_));
            } catch (S) {
                l(S);
            }
        }
        function g(_) {
            try {
                m(r.throw(_));
            } catch (S) {
                l(S);
            }
        }
        function m(_) {
            _.done ? c(_.value) : i(_.value).then(d, g);
        }
        m((r = r.apply(n, e || [])).next());
    });
};
class Ir {
    constructor(e, t = le){
        this._value = e, this._cancelError = t, this._queue = [], this._weightedWaiters = [];
    }
    acquire(e = 1, t = 0) {
        if (e <= 0) throw new Error(`invalid weight ${e}: must be positive`);
        return new Promise((r, i)=>{
            const c = {
                resolve: r,
                reject: i,
                weight: e,
                priority: t
            }, l = Lt(this._queue, (d)=>t <= d.priority);
            l === -1 && e <= this._value ? this._dispatchItem(c) : this._queue.splice(l + 1, 0, c);
        });
    }
    runExclusive(e) {
        return Or(this, arguments, void 0, function*(t, r = 1, i = 0) {
            const [c, l] = yield this.acquire(r, i);
            try {
                return yield t(c);
            } finally{
                l();
            }
        });
    }
    waitForUnlock(e = 1, t = 0) {
        if (e <= 0) throw new Error(`invalid weight ${e}: must be positive`);
        return this._couldLockImmediately(e, t) ? Promise.resolve() : new Promise((r)=>{
            this._weightedWaiters[e - 1] || (this._weightedWaiters[e - 1] = []), Dr(this._weightedWaiters[e - 1], {
                resolve: r,
                priority: t
            });
        });
    }
    isLocked() {
        return this._value <= 0;
    }
    getValue() {
        return this._value;
    }
    setValue(e) {
        this._value = e, this._dispatchQueue();
    }
    release(e = 1) {
        if (e <= 0) throw new Error(`invalid weight ${e}: must be positive`);
        this._value += e, this._dispatchQueue();
    }
    cancel() {
        this._queue.forEach((e)=>e.reject(this._cancelError)), this._queue = [];
    }
    _dispatchQueue() {
        for(this._drainUnlockWaiters(); this._queue.length > 0 && this._queue[0].weight <= this._value;)this._dispatchItem(this._queue.shift()), this._drainUnlockWaiters();
    }
    _dispatchItem(e) {
        const t = this._value;
        this._value -= e.weight, e.resolve([
            t,
            this._newReleaser(e.weight)
        ]);
    }
    _newReleaser(e) {
        let t = !1;
        return ()=>{
            t || (t = !0, this.release(e));
        };
    }
    _drainUnlockWaiters() {
        if (this._queue.length === 0) for(let e = this._value; e > 0; e--){
            const t = this._weightedWaiters[e - 1];
            t && (t.forEach((r)=>r.resolve()), this._weightedWaiters[e - 1] = []);
        }
        else {
            const e = this._queue[0].priority;
            for(let t = this._value; t > 0; t--){
                const r = this._weightedWaiters[t - 1];
                if (!r) continue;
                const i = r.findIndex((c)=>c.priority <= e);
                (i === -1 ? r : r.splice(0, i)).forEach((c)=>c.resolve());
            }
        }
    }
    _couldLockImmediately(e, t) {
        return (this._queue.length === 0 || this._queue[0].priority < t) && e <= this._value;
    }
}
function Dr(n, e) {
    const t = Lt(n, (r)=>e.priority <= r.priority);
    n.splice(t + 1, 0, e);
}
function Lt(n, e) {
    for(let t = n.length - 1; t >= 0; t--)if (e(n[t])) return t;
    return -1;
}
var xr = function(n, e, t, r) {
    function i(c) {
        return c instanceof t ? c : new t(function(l) {
            l(c);
        });
    }
    return new (t || (t = Promise))(function(c, l) {
        function d(_) {
            try {
                m(r.next(_));
            } catch (S) {
                l(S);
            }
        }
        function g(_) {
            try {
                m(r.throw(_));
            } catch (S) {
                l(S);
            }
        }
        function m(_) {
            _.done ? c(_.value) : i(_.value).then(d, g);
        }
        m((r = r.apply(n, e || [])).next());
    });
};
class Pt {
    constructor(e){
        this._semaphore = new Ir(1, e);
    }
    acquire() {
        return xr(this, arguments, void 0, function*(e = 0) {
            const [, t] = yield this._semaphore.acquire(1, e);
            return t;
        });
    }
    runExclusive(e, t = 0) {
        return this._semaphore.runExclusive(()=>e(), 1, t);
    }
    isLocked() {
        return this._semaphore.isLocked();
    }
    waitForUnlock(e = 0) {
        return this._semaphore.waitForUnlock(1, e);
    }
    release() {
        this._semaphore.isLocked() && this._semaphore.release();
    }
    cancel() {
        return this._semaphore.cancel();
    }
}
var f = /* @__PURE__ */ ((n)=>(n.Initializing = "initializing", n.Initialized = "initialized", n.Attaching = "attaching", n.Attached = "attached", n.Detaching = "detaching", n.Detached = "detached", n.Suspended = "suspended", n.Failed = "failed", n.Releasing = "releasing", n.Released = "released", n))(f || {});
class Lr {
    /**
   * Constructs a new DefaultRoomLifecycle instance.
   * @param logger An instance of the Logger.
   */ constructor(e){
        this._status = "initialized", this._emitter = new A(), this._logger = e;
    }
    /**
   * @inheritdoc
   */ get status() {
        return this._status;
    }
    /**
   * @inheritdoc
   */ get error() {
        return this._error;
    }
    /**
   * @inheritdoc
   */ onChange(e) {
        const t = v(e);
        return this._emitter.on(t), {
            off: ()=>{
                this._emitter.off(t);
            }
        };
    }
    setStatus(e) {
        const t = {
            current: e.status,
            error: e.error,
            previous: this._status
        };
        this._status = t.current, this._error = t.error, this._logger.info("room status changed", {
            ...t
        }), this._emitter.emit(t.current, t);
    }
    /**
   * Disposes of the room lifecycle instance, removing all listeners.
   * This method should be called when the room is being released to ensure proper cleanup.
   * @internal
   */ dispose() {
        this._logger.trace("DefaultRoomLifecycle.dispose();"), this._emitter.off(), this._logger.debug("DefaultRoomLifecycle.dispose(); disposed successfully");
    }
    /**
   * Checks if there are any listeners registered by users.
   * @internal
   * @returns true if there are listeners, false otherwise.
   */ hasListeners() {
        return N(this._emitter);
    }
}
class Pr {
    constructor(e, t, r){
        this._channelManager = e, this._roomLifecycle = t, this._logger = r, this._eventEmitter = new A(), this._hasAttachedOnce = !1, this._isExplicitlyDetached = !1, this._mutex = new Pt();
        const i = this._channelStateListener.bind(this), c = this._discontinuityOnAttachedListener.bind(this), l = this._discontinuityOnUpdateListener.bind(this), d = this._channelManager.get();
        this._unsubscribeChannelStateListener = L(d, i), this._offDiscontinuityAttached = L(d, "attached", c), this._offDiscontinuityUpdate = L(d, "update", l);
    }
    /**
   * Registers a handler for discontinuity events.
   * @param handler The function to be called when a discontinuity is detected
   * @returns An object with an off() method to deregister the handler
   */ onDiscontinuity(e) {
        this._logger.trace("RoomLifecycleManager.onDiscontinuity()");
        const t = v(e);
        return this._eventEmitter.on(J.Discontinuity, t), {
            off: ()=>{
                this._eventEmitter.off(J.Discontinuity, t);
            }
        };
    }
    /**
   * Attaches to the channel and updates room status accordingly.
   * If the room is released/releasing, this operation fails.
   * If already attached, this is a no-op.
   */ async attach() {
        await this._mutex.runExclusive(async ()=>{
            if (this._logger.trace("RoomLifecycleManager.attach();"), this._checkRoomNotReleasing("attach"), this._roomStatusIs(f.Attached)) {
                this._logger.debug("RoomLifecycleManager.attach(); room already attached, no-op");
                return;
            }
            const e = this._channelManager.get();
            this._logger.debug("RoomLifecycleManager.attach(); attaching room", {
                channelState: e.state
            });
            try {
                this._setStatus(f.Attaching), await e.attach(), this._setStatus(f.Attached), this._isExplicitlyDetached = !1, this._hasAttachedOnce = !0, this._logger.debug("RoomLifecycleManager.attach(); room attached successfully");
            } catch (t) {
                const r = t, i = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ably$2f$build$2f$ably$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ErrorInfo"](`failed to attach room: ${r.message}`, r.code, r.statusCode, r), c = this._mapChannelStateToRoomStatus(e.state);
                throw this._setStatus(c, i), i;
            }
        }, 1);
    }
    /**
   * Detaches from the channel and updates room status accordingly.
   * If the room is released/releasing, this operation fails.
   * If already detached, this is a no-op.
   */ async detach() {
        await this._mutex.runExclusive(async ()=>{
            if (this._logger.trace("RoomLifecycleManager.detach();"), this._roomStatusIs(f.Failed)) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ably$2f$build$2f$ably$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ErrorInfo"]("cannot detach room, room is in failed state", B.RoomInFailedState, 400);
            if (this._checkRoomNotReleasing("detach"), this._roomStatusIs(f.Detached)) {
                this._logger.debug("RoomLifecycleManager.detach(); room already detached, no-op");
                return;
            }
            const e = this._channelManager.get();
            this._logger.debug("RoomLifecycleManager.detach(); detaching room", {
                channelState: e.state
            });
            try {
                this._setStatus(f.Detaching), await e.detach(), this._isExplicitlyDetached = !0, this._setStatus(f.Detached), this._logger.debug("RoomLifecycleManager.detach(); room detached successfully");
            } catch (t) {
                const r = t, i = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ably$2f$build$2f$ably$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ErrorInfo"](`failed to detach room: ${r.message}`, r.code, r.statusCode, r), c = this._mapChannelStateToRoomStatus(e.state);
                throw this._setStatus(c, i), i;
            }
        }, 1);
    }
    /**
   * Releases the room by detaching the channel and releasing it from the channel manager.
   * If the channel is in a failed state, skips the detach operation.
   * Will retry detach until successful unless in failed state.
   */ async release() {
        await this._mutex.runExclusive(async ()=>{
            if (this._logger.trace("RoomLifecycleManager.release();"), this._roomStatusIs(f.Released)) {
                this._logger.debug("RoomLifecycleManager.release(); room already released, no-op");
                return;
            }
            if (this._roomStatusIs(f.Initialized) || this._roomStatusIs(f.Detached)) {
                this._logger.debug("RoomLifecycleManager.release(); room is initialized or detached, releasing immediately", {
                    status: this._roomLifecycle.status
                }), this._releaseChannel();
                return;
            }
            this._setStatus(f.Releasing);
            const e = this._channelManager.get();
            this._logger.debug("RoomLifecycleManager.release(); attempting channel detach before release", {
                channelState: e.state
            }), await this._channelDetachLoop(e), this._releaseChannel();
        }, 0);
    }
    /**
   * Maps an Ably channel state to a room status
   * @param channelState The Ably channel state to map.
   * @returns The corresponding room status.
   */ _mapChannelStateToRoomStatus(e) {
        switch(e){
            case "initialized":
                return f.Initialized;
            case "attaching":
                return f.Attaching;
            case "attached":
                return f.Attached;
            case "detaching":
                return f.Detaching;
            case "detached":
                return f.Detached;
            case "suspended":
                return f.Suspended;
            case "failed":
                return f.Failed;
            default:
                return this._logger.error("RoomLifecycleManager._mapChannelStateToRoomStatus(); unknown channel state", {
                    channelState: e
                }), f.Failed;
        }
    }
    _checkRoomNotReleasing(e) {
        switch(this._roomLifecycle.status){
            case f.Released:
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ably$2f$build$2f$ably$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ErrorInfo"](`cannot ${e} room, room is released`, B.RoomIsReleased, 400);
            case f.Releasing:
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ably$2f$build$2f$ably$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ErrorInfo"](`cannot ${e} room, room is currently releasing`, B.RoomIsReleasing, 400);
        }
    }
    /**
   * Returns the current room status
   * @param status The room status to check against.
   * @returns true if the room status matches, false otherwise.
   */ _roomStatusIs(e) {
        return this._roomLifecycle.status === e;
    }
    /**
   * Disposes of the room lifecycle manager, removing all listeners and subscriptions.
   * This method should be called when the room is being released to ensure proper cleanup.
   * @internal
   */ dispose() {
        this._unsubscribeChannelStateListener(), this._offDiscontinuityAttached(), this._offDiscontinuityUpdate(), this._eventEmitter.off();
    }
    /**
   * Checks if there are any listeners registered by users.
   * @internal
   * @returns true if there are listeners, false otherwise.
   */ hasListeners() {
        return N(this._eventEmitter);
    }
    _channelStateListener(e) {
        if (this._logger.debug("RoomLifecycleManager.channel state changed", {
            oldState: e.previous,
            newState: e.current,
            reason: e.reason,
            resumed: e.resumed
        }), this._operationInProgress()) {
            this._logger.debug("RoomLifecycleManager._startMonitoringChannelState(); ignoring channel state change - operation in progress", {
                status: this._roomLifecycle.status
            });
            return;
        }
        const t = this._mapChannelStateToRoomStatus(e.current);
        this._setStatus(t, e.reason);
    }
    _discontinuityOnAttachedListener(e) {
        if (!e.resumed && this._hasAttachedOnce && !this._isExplicitlyDetached) {
            const t = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ably$2f$build$2f$ably$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ErrorInfo"]("discontinuity detected", B.RoomDiscontinuity, e.reason?.statusCode ?? 0, e.reason);
            this._logger.warn("RoomLifecycleManager._startMonitoringDiscontinuity(); discontinuity detected", {
                error: t
            }), this._eventEmitter.emit(J.Discontinuity, t);
        }
    }
    _discontinuityOnUpdateListener(e) {
        if (!e.resumed && this._hasAttachedOnce && !this._isExplicitlyDetached && e.current === "attached" && e.previous === "attached") {
            const t = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ably$2f$build$2f$ably$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ErrorInfo"]("discontinuity detected", B.RoomDiscontinuity, e.reason?.statusCode ?? 0, e.reason);
            this._logger.warn("RoomLifecycleManager._startMonitoringDiscontinuity(); discontinuity detected", {
                error: t
            }), this._eventEmitter.emit(J.Discontinuity, t);
        }
    }
    async _channelDetachLoop(e) {
        for(;;){
            if (e.state === "failed") {
                this._logger.debug("RoomLifecycleManager._channelDetachLoop(); channel is failed, skipping detach");
                break;
            }
            try {
                await e.detach();
                break;
            } catch (r) {
                this._logger.error("RoomLifecycleManager._channelDetachLoop(); failed to detach channel during release", {
                    error: r
                }), await new Promise((i)=>setTimeout(i, 250));
            }
        }
    }
    _setStatus(e, t) {
        this._logger.debug("RoomLifecycleManager._setStatus(); updating room status", {
            oldStatus: this._roomLifecycle.status,
            newStatus: e,
            hasError: !!t
        }), this._roomLifecycle.setStatus({
            status: e,
            error: t
        });
    }
    _releaseChannel() {
        this._channelManager.release(), this._setStatus(f.Released), this._logger.debug("RoomLifecycleManager._releaseChannel(); room released successfully");
    }
    /**
   * Returns whether there is currently an operation (attach/detach/release) in progress
   * @returns True if an operation is in progress, false otherwise.
   */ _operationInProgress() {
        return this._mutex.isLocked();
    }
    testForceHasAttachedOnce(e) {
        this._logger.trace("RoomLifecycleManager.testForceHasAttachedOnce();", {
            firstAttach: e
        }), this._hasAttachedOnce = e;
    }
}
const de = {
    /**
   * The default typing options for a chat room.
   */ typing: {
        /**
     * The default time that a client will wait between sending one typing heartbeat and the next.
     *
     * Spec: CHA-T10.
     */ heartbeatThrottleMs: 1e4
    },
    /**
   * The default occupancy options for a chat room.
   */ occupancy: {
        /**
     * Whether to enable occupancy events.
     */ enableEvents: !1
    },
    /**
   * The default presence options for the room.
   */ presence: {
        enableEvents: !0
    },
    /**
   * The default options for messages.
   */ messages: {
        rawMessageReactions: !1,
        defaultMessageReactionType: z.Distinct
    }
}, Nr = (n)=>new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ably$2f$build$2f$ably$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ErrorInfo"](`invalid room configuration: ${n}`, 40001, 400), Ur = (n)=>{
    qr(n.typing);
}, qr = (n)=>{
    if (n.heartbeatThrottleMs <= 0) throw Nr("typing heartbeat interval must be greater than 0");
}, jr = (n)=>({
        ...de.typing,
        ...n?.typing
    }), kr = (n)=>({
        ...de.occupancy,
        ...n?.occupancy
    }), zr = (n)=>({
        ...de.presence,
        ...n?.presence
    }), Br = (n)=>({
        ...de.messages,
        ...n?.messages
    }), Fr = (n, e)=>({
        typing: jr(n),
        occupancy: kr(n),
        presence: zr(n),
        messages: Br(n),
        isReactClient: e
    }), Mt = (n, e)=>({
        name: n,
        data: e,
        extras: {
            ephemeral: !0
        }
    }), $r = (n)=>{
    const e = n.extras ? n.extras : {};
    return {
        ...n,
        extras: {
            ...e,
            ephemeral: !0
        }
    };
};
class Hr {
    constructor(e, t, r, i, c, l){
        this.name = e, this.clientId = t, this.createdAt = r, this.isSelf = i, this.metadata = c, this.headers = l, Object.freeze(this);
    }
}
const Vr = (n, e)=>{
    const t = n, r = t.data?.name && typeof t.data.name == "string" ? t.data.name : "", i = t.clientId ?? "", c = t.timestamp ? new Date(t.timestamp) : /* @__PURE__ */ new Date();
    return new Hr(r, i, c, e ? e === i : !1, t.data?.metadata ?? {}, t.extras?.headers ?? {});
};
class Gr {
    /**
   * Constructs a new `DefaultRoomReactions` instance.
   * @param channel The Realtime channel instance.
   * @param connection The connection instance.
   * @param clientId The client ID of the user.
   * @param logger An instance of the Logger.
   */ constructor(e, t, r, i){
        this._emitter = new A(), this._forwarder = (l)=>{
            const d = Vr(l, this._clientId);
            this._emitter.emit(Ce.Reaction, {
                type: Ce.Reaction,
                reaction: d
            });
        }, this._channel = e, this._connection = t, this._clientId = r, this._logger = i;
        const c = this._forwarder.bind(this);
        this._unsubscribeRoomReactionEvents = F(this._channel, [
            Ee.Reaction
        ], c);
    }
    /**
   * @inheritDoc
   */ send(e) {
        this._logger.trace("RoomReactions.send();", e);
        const { name: t, metadata: r, headers: i } = e;
        if (!t) return Promise.reject(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ably$2f$build$2f$ably$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ErrorInfo"]("unable to send reaction; name not set and it is required", 40001, 400));
        if (this._connection.state !== "connected") return Promise.reject(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ably$2f$build$2f$ably$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ErrorInfo"]("unable to send reaction; not connected to Ably", 4e4, 400));
        const c = {
            name: t,
            metadata: r ?? {}
        }, l = {
            name: Ee.Reaction,
            data: c,
            extras: {
                headers: i ?? {}
            }
        };
        return this._channel.publish($r(l));
    }
    /**
   * @inheritDoc
   */ subscribe(e) {
        this._logger.trace("RoomReactions.subscribe();");
        const t = v(e);
        return this._emitter.on(t), {
            unsubscribe: ()=>{
                this._logger.trace("RoomReactions.unsubscribe();"), this._emitter.off(t);
            }
        };
    }
    /**
   * Disposes of the room reactions instance, removing all listeners and subscriptions.
   * This method should be called when the room is being released to ensure proper cleanup.
   * @internal
   */ dispose() {
        this._unsubscribeRoomReactionEvents(), this._emitter.off();
    }
    /**
   * Checks if there are any listeners registered by users.
   * @internal
   * @returns true if there are listeners, false otherwise.
   */ hasListeners() {
        return N(this._emitter);
    }
}
class Wr extends A {
    /**
   * Constructs a new `DefaultTyping` instance.
   * @param options The options for typing in the room.
   * @param connection The connection instance.
   * @param channel The channel for the room.
   * @param clientId The client ID of the user.
   * @param logger An instance of the Logger.
   */ constructor(e, t, r, i, c){
        super(), this._timeoutMs = 2e3, this._mutex = new Pt(), this._internalSubscribeToEvents = (l)=>{
            const { name: d, clientId: g } = l;
            if (this._logger.trace("DefaultTyping._internalSubscribeToEvents(); received event", {
                name: d,
                clientId: g
            }), !g) {
                this._logger.error("DefaultTyping._internalSubscribeToEvents(); invalid clientId in received event", {
                    inbound: l
                });
                return;
            }
            d === T.Started || d === T.Stopped ? this._updateCurrentlyTyping(g, d) : this._logger.warn("DefaultTyping._internalSubscribeToEvents(); unrecognized event", {
                name: d
            });
        }, this._clientId = i, this._channel = r, this._connection = t, this._heartbeatThrottleMs = e.heartbeatThrottleMs, this._currentlyTyping = /* @__PURE__ */ new Map(), this._logger = c, this._unsubscribeTypingEvents = F(this._channel, [
            T.Started,
            T.Stopped
        ], this._internalSubscribeToEvents.bind(this));
    }
    /**
   * Clears all typing states.
   * This includes clearing all timeouts and the currently typing map.
   */ _clearAllTypingStates() {
        this._logger.debug("DefaultTyping._clearAllTypingStates(); clearing all typing states"), this._clearHeartbeatTimer(), this._clearCurrentlyTyping();
    }
    /**
   * Clears the heartbeat timer.
   */ _clearHeartbeatTimer() {
        this._logger.trace("DefaultTyping._clearHeartbeatTimer(); clearing heartbeat timer"), this._heartbeatTimerId && (clearTimeout(this._heartbeatTimerId), this._heartbeatTimerId = void 0);
    }
    /**
   * Clears the currently typing store and removes all timeouts for associated clients.
   */ _clearCurrentlyTyping() {
        this._logger.trace("DefaultTyping._clearCurrentlyTyping(); clearing current store and timeouts");
        for (const [, e] of this._currentlyTyping.entries())clearTimeout(e);
        this._currentlyTyping.clear();
    }
    /**
   * CHA-T16
   * @inheritDoc
   */ current() {
        return this._logger.trace("DefaultTyping.current();"), new Set(this._currentlyTyping.keys());
    }
    /**
   * @inheritDoc
   */ get channel() {
        return this._channel;
    }
    /**
   * Start the heartbeat timer. This will expire after the configured interval.
   */ _startHeartbeatTimer() {
        if (!this._heartbeatTimerId) {
            this._logger.trace("DefaultTyping.startHeartbeatTimer();");
            const e = this._heartbeatTimerId = setTimeout(()=>{
                this._logger.debug("DefaultTyping.startHeartbeatTimer(); heartbeat timer expired"), e === this._heartbeatTimerId && (this._heartbeatTimerId = void 0);
            }, this._heartbeatThrottleMs);
        }
    }
    /**
   * @inheritDoc
   */ async keystroke() {
        this._logger.trace("DefaultTyping.keystroke();"), this._mutex.cancel();
        try {
            await this._mutex.acquire();
        } catch (e) {
            if (e === le) {
                this._logger.debug("DefaultTyping.keystroke(); mutex was canceled by a later operation");
                return;
            }
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ably$2f$build$2f$ably$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ErrorInfo"]("mutex acquisition failed", 5e4, 500);
        }
        try {
            if (this._connection.state !== "connected") throw this._logger.error("DefaultTyping.keystroke(); connection is not connected", {
                status: this._connection.state
            }), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ably$2f$build$2f$ably$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ErrorInfo"]("cannot type, connection is not connected", 4e4, 400);
            if (this._heartbeatTimerId) {
                this._logger.debug("DefaultTyping.keystroke(); no-op, already typing and heartbeat timer has not expired");
                return;
            }
            await this._channel.publish(Mt(T.Started)), this._startHeartbeatTimer(), this._logger.trace("DefaultTyping.keystroke(); starting timers");
        } finally{
            this._logger.trace("DefaultTyping.keystroke(); releasing mutex"), this._mutex.release();
        }
    }
    /**
   * @inheritDoc
   */ async stop() {
        this._logger.trace("DefaultTyping.stop();"), this._mutex.cancel();
        try {
            await this._mutex.acquire();
        } catch (e) {
            if (e === le) {
                this._logger.debug("DefaultTyping.stop(); mutex was canceled by a later operation");
                return;
            }
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ably$2f$build$2f$ably$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ErrorInfo"]("mutex acquisition failed", 5e4, 500);
        }
        try {
            if (this._connection.state !== "connected") throw this._logger.error("DefaultTyping.stop(); connection is not connected", {
                status: this._connection.state
            }), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ably$2f$build$2f$ably$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ErrorInfo"]("cannot stop typing, connection is not connected", 4e4, 400);
            if (!this._heartbeatTimerId) {
                this._logger.debug("DefaultTyping.stop(); no-op, not currently typing");
                return;
            }
            await this._channel.publish(Mt(T.Stopped)), this._logger.trace("DefaultTyping.stop(); clearing timers"), clearTimeout(this._heartbeatTimerId), this._heartbeatTimerId = void 0;
        } finally{
            this._logger.trace("DefaultTyping.stop(); releasing mutex"), this._mutex.release();
        }
    }
    /**
   * @inheritDoc
   */ subscribe(e) {
        this._logger.trace("DefaultTyping.subscribe();");
        const t = v(e);
        return this.on(t), {
            unsubscribe: ()=>{
                this._logger.trace("DefaultTyping.unsubscribe();"), this.off(t);
            }
        };
    }
    /**
   * @inheritDoc
   */ // CHA-RL3h
    async dispose() {
        for(this._logger.trace("DefaultTyping.dispose();");;)try {
            this._mutex.cancel(), await this._mutex.acquire();
            break;
        } catch (e) {
            if (e === le) this._logger.debug("DefaultTyping.dispose(); mutex was canceled"), await new Promise((t)=>setTimeout(t, 200)), this._logger.debug("DefaultTyping.dispose(); retrying mutex acquisition");
            else {
                this._logger.error("DefaultTyping.dispose(); failed to acquire mutex; could not complete resource disposal", {
                    error: e
                });
                return;
            }
        }
        this._clearAllTypingStates(), this._unsubscribeTypingEvents(), this.off(), this._mutex.release();
    }
    /**
   * Update the currently typing users. This method is called when a typing event is received.
   * It will also acquire a mutex to ensure that the currentlyTyping state is updated safely.
   * @param clientId The client ID of the user.
   * @param event The typing event.
   */ _updateCurrentlyTyping(e, t) {
        this._logger.trace("DefaultTyping._updateCurrentlyTyping();", {
            clientId: e,
            event: t
        }), t === T.Started ? this._handleTypingStart(e) : this._handleTypingStop(e);
    }
    /**
   * Starts a new inactivity timer for the client.
   * This timer will expire after the configured timeout,
   * which is the sum of the heartbeat interval and the inactivity timeout.
   * @param clientId The client ID for which to start the timer.
   * @returns The timeout ID for the new timer.
   */ _startNewClientInactivityTimer(e) {
        this._logger.trace("DefaultTyping._startNewClientInactivityTimer(); starting new inactivity timer", {
            clientId: e
        });
        const t = setTimeout(()=>{
            if (this._logger.trace("DefaultTyping._startNewClientInactivityTimer(); client typing timeout expired", {
                clientId: e
            }), this._currentlyTyping.get(e) !== t) {
                this._logger.debug("DefaultTyping._startNewClientInactivityTimer(); timeout already cleared; ignoring", {
                    clientId: e
                });
                return;
            }
            this._currentlyTyping.delete(e), this.emit(k.SetChanged, {
                type: k.SetChanged,
                currentlyTyping: new Set(this._currentlyTyping.keys()),
                change: {
                    clientId: e,
                    type: T.Stopped
                }
            });
        }, this._heartbeatThrottleMs + this._timeoutMs);
        return t;
    }
    /**
   * Handles logic for TypingEventType.Started, including starting a new timeout or resetting an existing one.
   * @param clientId The client ID that started typing.
   */ _handleTypingStart(e) {
        this._logger.debug("DefaultTyping._handleTypingStart();", {
            clientId: e
        });
        const t = this._startNewClientInactivityTimer(e), r = this._currentlyTyping.get(e);
        this._currentlyTyping.set(e, t), r ? (this._logger.debug("DefaultTyping._handleTypingStart(); received heartbeat for currently typing client", {
            clientId: e
        }), clearTimeout(r)) : (this._logger.debug("DefaultTyping._handleTypingStart(); new client started typing", {
            clientId: e
        }), this.emit(k.SetChanged, {
            type: k.SetChanged,
            currentlyTyping: new Set(this._currentlyTyping.keys()),
            change: {
                clientId: e,
                type: T.Started
            }
        }));
    }
    /**
   * Handles logic for TypingEventType.Stopped, including clearing the timeout for the client.
   * @param clientId The client ID that stopped typing.
   */ _handleTypingStop(e) {
        const t = this._currentlyTyping.get(e);
        if (!t) {
            this._logger.trace('DefaultTyping._handleTypingStop(); received "Stop" event for client not in currentlyTyping list', {
                clientId: e
            });
            return;
        }
        this._logger.debug("DefaultTyping._handleTypingStop(); client stopped typing", {
            clientId: e
        }), clearTimeout(t), this._currentlyTyping.delete(e), this.emit(k.SetChanged, {
            type: k.SetChanged,
            currentlyTyping: new Set(this._currentlyTyping.keys()),
            change: {
                clientId: e,
                type: T.Stopped
            }
        });
    }
    get heartbeatThrottleMs() {
        return this._heartbeatThrottleMs;
    }
    get hasHeartbeatTimer() {
        return !!this._heartbeatTimerId;
    }
}
class Kr {
    /**
   * Constructs a new Room instance.
   * @param name The unique identifier of the room.
   * @param nonce A random identifier for the room instance, useful in debugging and logging.
   * @param options The options for the room.
   * @param realtime An instance of the Ably Realtime client.
   * @param chatApi An instance of the ChatApi.
   * @param logger An instance of the Logger.
   */ constructor(e, t, r, i, c, l){
        Ur(r), this._nonce = t, this._logger = l.withContext({
            roomName: e,
            roomNonce: t
        }), this._logger.debug("Room();", {
            options: r
        }), this._name = e, this._options = r, this._chatApi = c, this._lifecycle = new Lr(this._logger);
        const d = this._channelManager = this._getChannelManager(r, i, this._logger), g = d.get();
        this._messages = new Sr(e, r.messages, g, this._chatApi, i.auth.clientId, this._logger), this._presence = new Tt(g, i.auth.clientId, this._logger, r), this._typing = new Wr(r.typing, i.connection, g, i.auth.clientId, this._logger), this._reactions = new Gr(g, i.connection, i.auth.clientId, this._logger), this._occupancy = new Rt(e, g, this._chatApi, this._logger, r), this._lifecycleManager = new Pr(d, this._lifecycle, this._logger);
        let m = !1;
        this._finalizer = async ()=>{
            if (m) {
                this._logger.debug("Room.finalizer(); already finalized");
                return;
            }
            await this._lifecycleManager.release(), this._lifecycleManager.dispose(), this._messages.dispose(), this._presence.dispose(), this._reactions.dispose(), this._occupancy.dispose(), await this._typing.dispose(), this._lifecycle.dispose(), m = !0;
        };
    }
    /**
   * Gets the channel manager for the room, which handles merging channel options together and creating channels.
   * @param options The room options.
   * @param realtime  An instance of the Ably Realtime client.
   * @param logger An instance of the Logger.
   * @returns The channel manager instance.
   */ _getChannelManager(e, t, r) {
        const i = new Er(this._name, t, r, e.isReactClient);
        return i.mergeOptions(Rt.channelOptionMerger(e)), i.mergeOptions(Tt.channelOptionMerger(e)), i.mergeOptions(It.channelOptionMerger(e)), i;
    }
    /**
   * @inheritdoc
   */ get name() {
        return this._name;
    }
    /**
   * @inheritDoc
   */ options() {
        return D(this._options);
    }
    /**
   * @inheritdoc
   */ get messages() {
        return this._messages;
    }
    /**
   * @inheritdoc
   */ get presence() {
        return this._presence;
    }
    /**
   * @inheritdoc
   */ get reactions() {
        return this._reactions;
    }
    /**
   * @inheritdoc
   */ get typing() {
        return this._typing;
    }
    /**
   * @inheritdoc
   */ get occupancy() {
        return this._occupancy;
    }
    /**
   * @inheritdoc
   */ get status() {
        return this._lifecycle.status;
    }
    /**
   * @inheritdoc
   */ get error() {
        return this._lifecycle.error;
    }
    /**
   * @inheritdoc
   */ onStatusChange(e) {
        return this._lifecycle.onChange(e);
    }
    /**
   * @inheritdoc
   */ async attach() {
        return this._logger.trace("Room.attach();"), this._lifecycleManager.attach();
    }
    /**
   * @inheritdoc
   */ async detach() {
        return this._logger.trace("Room.detach();"), this._lifecycleManager.detach();
    }
    /**
   * Releases resources associated with the room.
   * @returns A promise that resolves when the room is released.
   */ release() {
        return this._logger.trace("Room.release();"), this._finalizer();
    }
    /**
   * A random identifier for the room instance, useful in debugging and logging.
   * @returns The nonce.
   */ get nonce() {
        return this._nonce;
    }
    /**
   * @internal
   * @returns The internal room lifecycle.
   */ get lifecycle() {
        return this._lifecycle;
    }
    /**
   * @internal
   * @returns The room lifecycle manager.
   */ get lifecycleManager() {
        return this._lifecycleManager;
    }
    /**
   * @inheritdoc
   */ onDiscontinuity(e) {
        return this._logger.trace("Room.onDiscontinuity();"), this._lifecycleManager.onDiscontinuity(e);
    }
    /**
   * @inheritdoc
   */ get channel() {
        return this._channelManager.get();
    }
}
class Qr {
    /**
   * Constructs a new Rooms instance.
   * @param realtime An instance of the Ably Realtime client.
   * @param clientOptions The client options from the chat instance.
   * @param logger An instance of the Logger.
   */ constructor(e, t, r){
        this._rooms = /* @__PURE__ */ new Map(), this._releasing = /* @__PURE__ */ new Map(), this._isReact = !1, this._disposed = !1, this._realtime = e, this._chatApi = new vr(e, r), this._clientOptions = t, this._logger = r;
    }
    /**
   * @inheritDoc
   */ async get(e, t) {
        this._logger.trace("Rooms.get();", {
            roomName: e
        }), this._ensureNotDisposed();
        const r = this._rooms.get(e);
        if (r) return this._handleExistingRoom(r, e, t);
        const i = this._releasing.get(e), c = Et();
        return i ? this._waitForReleaseAndCreateRoom(e, c, t, i) : this._createNewRoom(e, c, t);
    }
    /**
   * @inheritDoc
   */ async release(e) {
        this._logger.trace("Rooms.release();", {
            roomName: e
        });
        const t = this._rooms.get(e), r = this._releasing.get(e);
        return t ? r ? this._handleConcurrentRelease(e, t, r) : this._performRoomRelease(e, t) : this._handleNonExistentRoomRelease(e, r);
    }
    /**
   * Disposes all rooms that are currently in the rooms map and waits for any ongoing release operations to complete.
   * This method releases all rooms concurrently, waits for any in-flight releases to finish, and clears the rooms map.
   * After this method resolves, all rooms will have been fully released and cleaned up.
   * @internal
   * @returns A promise that resolves when all rooms have been released.
   */ async dispose() {
        this._logger.trace("Rooms.dispose();"), this._disposed = !0;
        const e = [
            ...this._rooms.keys()
        ];
        if (e.length === 0) {
            this._logger.debug("Rooms.dispose(); no rooms to release");
            return;
        }
        const t = e.map((c)=>this.release(c)), r = [
            ...this._releasing.values()
        ], i = [
            ...t,
            ...r
        ];
        this._logger.debug("Rooms.dispose(); releasing rooms", {
            roomCount: e.length,
            roomNames: e
        }), await Promise.all(i), this._logger.debug("Rooms.dispose(); all rooms released successfully");
    }
    /**
   * Get the client options used to create the Chat instance.
   * @returns ChatClientOptions
   */ get clientOptions() {
        return this._clientOptions;
    }
    /**
   * @inheritDoc
   */ get count() {
        return this._rooms.size;
    }
    /**
   * Ensures the rooms instance has not been disposed.
   */ _ensureNotDisposed() {
        if (this._disposed) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ably$2f$build$2f$ably$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ErrorInfo"]("cannot get room, rooms instance has been disposed", 4e4, 400);
    }
    /**
   * Handles the case where a room already exists.
   * @param existingRoom The existing room entry in the map.
   * @param name The unique identifier of the room.
   * @param options The options for the room.
   * @returns A promise that resolves to the existing room.
   */ async _handleExistingRoom(e, t, r) {
        if (!Y(e.options, r)) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ably$2f$build$2f$ably$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ErrorInfo"]("room already exists with different options", 4e4, 400);
        return this._logger.debug("Rooms.get(); returning existing room", {
            roomName: t,
            nonce: e.nonce,
            options: r
        }), await e.promise;
    }
    /**
   * Creates a new room when no existing room or ongoing release exists.
   * @param name The unique identifier of the room.
   * @param nonce A random, internal identifier useful for debugging and logging.
   * @param options The options for the room.
   * @returns A new room object.
   */ _createNewRoom(e, t, r) {
        const i = this._makeRoom(e, t, r), c = {
            promise: Promise.resolve(i),
            nonce: t,
            options: r
        };
        return this._rooms.set(e, c), this._logger.debug("Rooms.get(); returning new room", {
            roomName: e,
            nonce: i.nonce
        }), i;
    }
    /**
   * Waits for an ongoing release to complete, then creates a new room.
   * @param name The unique identifier of the room.
   * @param nonce A random, internal identifier useful for debugging and logging.
   * @param options The options for the room.
   * @param ongoingRelease The promise of an ongoing release operation.
   * @returns A promise that resolves to a room.
   */ async _waitForReleaseAndCreateRoom(e, t, r, i) {
        const c = new AbortController(), l = this._createAbortableRoomPromise(e, t, r, i, c);
        return this._rooms.set(e, {
            promise: l,
            options: r,
            nonce: t,
            abort: c
        }), this._logger.debug("Rooms.get(); creating new promise dependent on previous release", {
            roomName: e
        }), await l;
    }
    /**
   * Creates a promise that can be aborted if the room is released before completion.
   * @param name The unique identifier of the room.
   * @param nonce A random, internal identifier useful for debugging and logging.
   * @param options The options for the room.
   * @param ongoingRelease A promise that resolves when the previous release operation is complete.
   * @param abortController An AbortController to manage the abort signal.
   * @returns A promise that resolves to a new room or rejects if the operation is aborted.
   */ _createAbortableRoomPromise(e, t, r, i, c) {
        return new Promise((l, d)=>{
            const g = ()=>{
                this._logger.debug("Rooms.get(); aborted before init", {
                    roomName: e
                }), d(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ably$2f$build$2f$ably$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ErrorInfo"]("room released before get operation could complete", B.RoomReleasedBeforeOperationCompleted, 400));
            };
            c.signal.addEventListener("abort", g), i.then(()=>{
                if (c.signal.aborted) {
                    this._logger.debug("Rooms.get(); aborted before releasing promise resolved", {
                        roomName: e
                    });
                    return;
                }
                this._logger.debug("Rooms.get(); releasing finished", {
                    roomName: e
                });
                const m = this._makeRoom(e, t, r);
                c.signal.removeEventListener("abort", g), l(m);
            }).catch((m)=>{
                c.signal.removeEventListener("abort", g), d(m);
            });
        });
    }
    /**
   * Handles release when no room exists.
   * @param name The unique identifier of the room.
   * @param ongoingRelease An ongoing release promise, if any.
   * @returns A promise that resolves when the release operation is complete.
   */ async _handleNonExistentRoomRelease(e, t) {
        if (t) {
            this._logger.debug("Rooms.release(); waiting for previous release call", {
                roomName: e
            }), await t;
            return;
        }
        this._logger.debug("Rooms.release(); room does not exist", {
            roomName: e
        });
    }
    /**
   * Handles release when there's already a release in progress.
   * @param name The unique identifier of the room.
   * @param existingRoom The existing room entry in the map.
   * @param ongoingRelease The promise of an ongoing release operation.
   */ async _handleConcurrentRelease(e, t, r) {
        t.abort && (this._logger.debug("Rooms.release(); aborting get call", {
            roomName: e,
            existingNonce: t.nonce
        }), t.abort.abort(), this._rooms.delete(e)), await r;
    }
    /**
   * Performs the actual room release operation.
   * @param name The unique identifier of the room.
   * @param existingRoom The existing room entry in the map.
   */ async _performRoomRelease(e, t) {
        this._rooms.delete(e);
        const r = this._executeRoomRelease(e, t);
        this._releasing.set(e, r), this._logger.debug("Rooms.release(); creating new release promise", {
            roomName: e,
            nonce: t.nonce
        }), await r;
    }
    /**
   * Executes the room release and cleanup.
   * @param name The unique identifier of the room.
   * @param existingRoom The existing room entry in the map.
   */ async _executeRoomRelease(e, t) {
        const r = await t.promise;
        this._logger.debug("Rooms.release(); releasing room", {
            roomName: e,
            nonce: t.nonce
        }), await r.release(), this._logger.debug("Rooms.release(); room released", {
            roomName: e,
            nonce: t.nonce
        }), this._releasing.delete(e);
    }
    /**
   * makes a new room object
   * @param name The unique identifier of the room.
   * @param nonce A random, internal identifier useful for debugging and logging.
   * @param options The options for the room.
   * @returns DefaultRoom A new room object.
   */ _makeRoom(e, t, r) {
        return new Kr(e, t, Fr(r, this._isReact), this._realtime, this._chatApi, this._logger);
    }
    /**
   * Sets react JS mode.
   */ useReact() {
        this._logger.trace("Rooms.useReact();"), this._isReact = !0;
    }
}
class Xr {
    /**
   * Constructor for Chat
   *
   * **Important**: The Ably Realtime client must have a clientId set. This can be done by configuring
   * token-based authentication that returns a token with a clientId, or by setting
   * the clientId directly in the Realtime client options.
   * @example
   * ```typescript
   * import * as Ably from 'ably';
   * import { ChatClient } from '@ably/chat';
   *
   * // Preferred in production: Use auth URL that returns a token with clientId
   * const realtime = new Ably.Realtime({
   *   authUrl: '/api/ably-auth', // Your server endpoint that returns an Ably token with clientId
   *   authMethod: 'POST'
   * });
   * const chatClient = new ChatClient(realtime);
   *
   * // Alternative for development and server-side operations: Set clientId directly (requires API key)
   * const realtime = new Ably.Realtime({
   *   key: 'your-ably-api-key',
   *   clientId: 'user-123'
   * });
   * const chatClient = new ChatClient(realtime);
   * ```
   * @param realtime - The Ably Realtime client.
   * @param clientOptions - The client options.
   */ constructor(e, t){
        this._realtime = e, this._clientOptions = cr(t), this._nonce = Et(), this._logger = ar(this._clientOptions).withContext({
            chatClientNonce: this._nonce
        }), this._connection = new gr(e, this._logger), this._rooms = new Qr(e, this._clientOptions, this._logger), this._addAgent("chat-js"), this._logger.trace(`ably chat client version ${ge}; initialized`);
    }
    /**
   * Returns the rooms object, which provides access to chat rooms.
   * @returns The rooms object.
   */ get rooms() {
        return this._rooms;
    }
    /**
   * Returns the underlying connection to Ably, which can be used to monitor the client's
   * connection to Ably servers.
   * @returns The connection object.
   */ get connection() {
        return this._connection;
    }
    /**
   * Returns the clientId of the current client.
   * @returns The clientId.
   */ get clientId() {
        return this._realtime.auth.clientId;
    }
    /**
   * Returns the underlying Ably Realtime client.
   * @returns The Ably Realtime client.
   */ get realtime() {
        return this._realtime;
    }
    /**
   * Returns the resolved client options for the client, including any defaults that have been set.
   * @returns The client options.
   */ get clientOptions() {
        return this._clientOptions;
    }
    /**
   * Returns the logger instance for the client.
   * @internal
   * @returns The logger instance.
   */ get logger() {
        return this._logger;
    }
    /**
   * Adds additional agent information to the client.
   * Used internally to add React-specific agent information.
   * @internal
   */ addReactAgent() {
        this._addAgent("chat-react"), this._rooms.useReact();
    }
    /**
   * Adds additional agent information to the client.
   * This is used internally to add a specific agent with a version.
   * @param agent - The agent to add.
   * @param version - The version of the agent, defaults to the current client version.
   * @internal
   */ addAgentWithVersion(e, t) {
        this._addAgent(e, t), this._logger.trace(`Added agent ${e} with version ${t}`);
    }
    /**
   * Disposes of the ChatClient instance, cleaning up any resources and rendering it unusable.
   * This method will release all rooms before disposing of the client.
   */ async dispose() {
        this._logger.trace("ChatClient.dispose();"), await this._rooms.dispose(), this._connection.dispose(), this._logger.debug("ChatClient.dispose(); client disposed successfully");
    }
    /**
   * Sets the agent string for the client.
   * @param agent - The agent to add.
   * @param version - The version of the agent, defaults to the current client version.
   * @internal
   */ _addAgent(e, t) {
        const r = this._realtime;
        r.options.agents = {
            ...r.options.agents ?? r.options.agents,
            [e]: t ?? ge
        };
    }
}
;
 //# sourceMappingURL=ably-chat.js.map
}),
]);

//# sourceMappingURL=node_modules_c90bf583._.js.map